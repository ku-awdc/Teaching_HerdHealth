% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Importing and Cleaning Data in the R tidyverse},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering

\title{Importing and Cleaning Data in the R tidyverse}
\author{}
\date{\vspace{-2.5em}}

\begin{document}
\maketitle

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{matt-denwood-university-of-copenhagen}{%
\subparagraph{Matt Denwood, University of
Copenhagen}\label{matt-denwood-university-of-copenhagen}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

R has existed for over 25 years, and is itself based on a programming
language called S that was invented in 1976. Over that time, many
different styles of R coding have evolved, and consequently there are a
large number of different ways of accomplishing the same tasks. The most
modern way of using R is within the tidyverse
(\url{http://tidyverse.org}) - this is a collection of extensions to
base R that are focussed on making it as easy as possible to do data
science in R: i.e.~import, process and analyse the types of datasets
that are typical to epidemiology. Central to this are three key
concepts:

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\tightlist
\item
  Tidy datasets are much easier to work with than messy datasets
\item
  Always check for data entry mistakes in your data - never just assume
  that it is all correct
\item
  R code should be as clear and easy to read as possible even for users
  that are not expert programmers
\end{enumerate}

R code written using the tidyverse looks a bit different to the code
using base R that you might have used before, but it makes it much
easier to create code that does relatively compex things with your data.
This tutorial will explain some of the key features of importing,
cleaning and checking data using the calf fetuses dataset as an example.
For more background on the study that generated this dataset, see the
published article at:

\url{https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0207682}

The code starts off very simple in Section 1, but Sections 2 and 3 are a
bit more advanced, so take your time and understand each step before
moving onto the next. Make sure to run every step of the code in R in
the same order as it is given here; otherwise you will either get errors
or different results from some of the steps. For a more complete (and
even longer) introduction to tidyverse I thoroughly recommend the book
`R for Data Science': a free online version is available from
\url{https://r4ds.had.co.nz/}

For this tutorial we will assume that you have installed both the latest
version of R (\url{http://cran.r-project.org}) and the latest version of
RStudio (\url{http://rstudio.org}), but you do not need to have any
prior experience with R. Start by opening RStudio and creating a new R
script by clicking `File' then `New File' then `R Script'. You should
see a blank text file appear in the text file window in the top-left
corner of R studio. Save it (click on File, then Save) and name it
`tidy\_fetuses.R' (make sure that you save this file in the same folder
as the `calf\_fetuses.xlsx' data file that you have downloaded from
Absalon). The RStudio window also contains three other windows: the R
console (bottom left), Environment/History/Connections window (top
right), and the Files/Plots/Packages/Help/Viewer window (bottom right).
You can copy code given here in `R code chunks' like this one:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2}\OperatorTok{+}\DecValTok{4}
\end{Highlighting}
\end{Shaded}

\ldots and paste them into your (currently blank) tidy\_fetuses.R script
in the text file window within RStudio. To run the code, place the
cursor somewhere on the line you want to run, and click `Run' (or use
the keyboard shortcut control/command + enter). You will see that
RStudio copies the code from your text window (top left) and enters it
into the R console (bottom left). You can also copy the code and
manually paste it into the R console, but this takes longer so practice
using the `Run' shortcut. Avoid re-typing code directly into the R
console as even the smallest typing mistake can lead to an error.

This document also displays the result of running these code chunks,
which should match what you see when you run the code in R. For example,
the code above should give the following output in the R console window
directly below the command:

\begin{verbatim}
## [1] 6
\end{verbatim}

To run multiple lines at once, highlight them all and click `Run'. To
run the entire R script file click `Source'.

It is a good idea to write comments for yourself in the R script file to
remind you what the R code is doing when you come to look at it later,
and it is crucial if you are going to share the code with anyone else.
Any lines starting with \# are ignored by R, for example:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# This is a comment - it will be ignored by R}
\DecValTok{1}\OperatorTok{+}\DecValTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 5
\end{verbatim}

It can also be useful to `comment out' R code that you don't want to run
but do want to leave in the R script for later reference: for example
the 8+9 calculation in the code chunk below is ignored by R because that
line starts with a \#:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# 8+9}
\end{Highlighting}
\end{Shaded}

If you want to run the calculation, you can either delete the \# and run
the whole line, or highlight just the 8+9 and click run.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{section-1-basic-data-handling}{%
\subsection{Section 1: basic data
handling}\label{section-1-basic-data-handling}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{installing-tidyverse}{%
\subsubsection{Installing tidyverse}\label{installing-tidyverse}}

You need to have the tidyverse package installed within R. If you have
not already installed the package (or have recently re-installed R),
then click the `Tools' menu then `Install Packages' then type
`tidyverse' and click on `Install'. If you prefer, you can also paste
the following command into your R script:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{'tidyverse'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If you do this then remember to comment out this code using the \#
symbol afterwards, otherwise the package will be re-installed (and
re-downloaded!) every time you run the code.

You only need to install a package once, but you need to load it every
time you restart R. Do this using the library() function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{'tidyverse'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## -- Attaching packages ------------------- tidyverse 1.3.0 --
\end{verbatim}

\begin{verbatim}
## v ggplot2 3.2.1     v purrr   0.3.3
## v tibble  2.1.3     v dplyr   0.8.3
## v tidyr   1.0.2     v stringr 1.4.0
## v readr   1.3.1     v forcats 0.4.0
\end{verbatim}

\begin{verbatim}
## -- Conflicts ---------------------- tidyverse_conflicts() --
## x dplyr::filter() masks stats::filter()
## x dplyr::lag()    masks stats::lag()
\end{verbatim}

When you run this code, you should see similar output to that shown
above. The `Conflicts' (and small red crosses next to them) are to be
expected, so you can safely ignore these. But if you get different
output to what is shown above, or if you have any problems with package
installation such as messages saying that packages are not available for
your version of R, then make sure that R and RStudio are updated to the
latest versions and try again. If you still have problems, then let us
know ASAP so we can try to resolve them (the most common problems are
due to old operating system versions or restricted access on
institutional computers).

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{preparing-your-data}{%
\subsubsection{Preparing your data}\label{preparing-your-data}}

Before reading an Excel file into R, you will need to make sure that the
relevant sheet is laid out in an appropriate way. The first row should
contain the column names, and all columns must have a unique name. You
will make life much easier for yourself if the column names are concise,
and do not use spaces, special characters (e.g.~+ - / * \& \% â‚¬ , etc),
dates, or non-English characters (e.g.~Ã¥ Ã¦ Ã¸). You can use an underscore
( \_ ) to create two-word names e.g.~birth\_date. The second row should
be the start of the data: do not include any blank rows below the column
names. If there is anything entered below the last row of data (for
example comments or formulae such as averages) then delete these rows.

Each column can either be a number, date/time, or text - but this must
be consistent within a column. It is a good idea to ensure that
date/time columns are stored correctly by selecting the column and going
to `Format' -\textgreater{} `Cells' and selecting either date or time as
the format. As a general rule it is a much better idea to record
categorical data (e.g.~gender) as character rather than number codes
e.g.~male/female rather than 1/2. Remember that all cell comments and
formatting (e.g.~bold, colours etc) will be completely ignored by R when
reading the data, so DO NOT use any type of comment or format to
represent important information: create a new column instead. If you
have an observation that is missing then jut leave the cell blank - do
not use any special codes or text (such as ``NA'' or ``N/A'' or
``missing'') to indicate missing observations as this will make your
life more difficult than it needs to be.

Finally, ensure that you do not have any stray text or numbers entered
outside of the columns of data, or rows that do not form part of the
data placed within the same sheet. If you want to have e.g.~comments,
notes, graphs or formulas to summarise your data in Excel, then create a
second sheet specifically for this information. It is a very good idea
to also have a separate `data key' sheet where you record the meaning of
all of the varibles, where the data has come from, and any other
relevant meta-data such as the collection date or any other important
notes that you might need to remember when you come back to the data
later on. This will also make it much easier for you to share the data
with others.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{reading-data}{%
\subsubsection{Reading data}\label{reading-data}}

The first thing you are going to want to do is to read your data file.
This can be in a number of formats, but the most common is an Excel
file. For this we need to load the readxl package (this is installed as
part of tidyverse, but not loaded by default):

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{'readxl'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You will then need to make sure that your working directory is set
correctly so that R can find the data file on your hard drive. Go to the
`Session' menu, `Set Working Directory', and `Choose Directory' and then
select the folder that contains the calf foetuses dataset that you
downloaded from Absalon as part of the previous task. Check that the
name of the downloaded file actually is calf\_fetuses.xlsx and has not
been renamed automatically during the download process (if for example
the file is named ``calf\_fetuses (1).xlsx'' then the code will not
work).

You should now be able to load the data from a specified sheet within
the Excel file using:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\KeywordTok{read_excel}\NormalTok{(}\StringTok{'calf_fetuses.xlsx'}\NormalTok{, }\DataTypeTok{sheet=}\StringTok{'calf_fetuses'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

When you run this code, nothing much seems to happen (unless you get an
error saying that the file could not be found, in which case check that
you have included the .xlsx or .xlx file extension, and that the file
has not been renamed during the download process). But in fact R has
read the data from the Excel file, and assigned the resulting `data
frame' (which is like an Excel worksheet) called `fetuses' (using the
assignment operator \textless-) in which the data is now being stored
within your R envirnoment. If you look closely you should see the text
`fetuses 262 obs. of 18 variables' appear under `Data' in the
`Environment' tab of the top-right window within RStudio. Click on the
name `fetuses' to open a new tab with the data in table form.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{looking-at-your-data}{%
\subsubsection{Looking at your data}\label{looking-at-your-data}}

There are several methods of examining and visualising your data, but
here we will stick with the tidyverse way of doing things. You may
already know how to do some of this in base R - it is OK to use methods
you are already familiar with, but try not to mix different styles too
much. That can sometimes lead to strange errors and often leads to messy
code \ldots{} we want everything to be tidy!

The tidyverse revolves around data frames - these allow us to keep all
related data together, in a consistent format where we know that all
columns have the same number of rows and each row corresponds to a
specific set of observations. When working with data in the tidyverse,
we will therefore nearly always be working within these data frames. To
do something within a data frame, we first type the name of the data
frame, then the special `pipe' or `chaining' operator \%\textgreater\%,
and then a function that we want to apply to the data frame. For
example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}\StringTok{ }\KeywordTok{nrow}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 262
\end{verbatim}

This takes the data frame fetuses, and applies the function nrow() to
the data - the output is the number of rows of the dataset. In base R we
would achieve the same thing using:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{nrow}\NormalTok{(fetuses)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 262
\end{verbatim}

These two bits of code are in fact equivalent - the \%\textgreater\%
operator automatically takes the data frame input from the left hand
side and passes it (as the first argument) to the function on the right
hand side. The advantage to using the \%\textgreater\% operator is that
we can build up a more complex chain of commands more easily - you will
see this later on. There is even a handy keyboard shortcut to type the
operator: command/control + shift + m.

A useful function to find out even more about the structure of the data
is str() - this tells us how R is storing each of the columns (called
`variables') within the data frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}\StringTok{ }\KeywordTok{str}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Classes 'tbl_df', 'tbl' and 'data.frame':    262 obs. of  18 variables:
##  $ parity            : num  3 2 1 1 2 3 2 2 6 4 ...
##  $ age_days          : num  274 196 259 249 221 221 177 82 193 142 ...
##  $ weight_kg         : num  35.5 10.2 27.1 29.1 16.6 ...
##  $ crl_cm            : num  86.8 61.8 89.3 83 75.4 77.7 55.4 10.4 62.4 35.4 ...
##  $ head_width_mm     : num  128 83.8 121 118 100.6 ...
##  $ head_length_mm    : num  239 154 220 215 183 ...
##  $ hair_coronary_band: chr  "Y" "Y" "Y" "Y" ...
##  $ hair_ear          : chr  "Y" "Y" "Y" "Y" ...
##  $ hair_eyelid       : chr  "Y" "Y" "Y" "Y" ...
##  $ hair_tail         : chr  "Y" "Y" "Y" "Y" ...
##  $ hair_hornbud      : chr  "Y" "Y" "Y" "Y" ...
##  $ tactile_muzzle    : chr  "Visible" "Visible" "Visible" "Visible" ...
##  $ tactile_eyebrow   : chr  "Visible" "Visible" "Visible" "Visible" ...
##  $ tactile_eyelash   : chr  "Visible" "Visible" "Visible" "Visible" ...
##  $ eye_op_close      : chr  "Open" "Open" "Open" "Open" ...
##  $ papillae_tongue   : chr  "Whole tongue" "Whole tongue" "Whole tongue" "Whole tongue" ...
##  $ eyelid            : chr  "Y" "Y" "Y" "Y" ...
##  $ sex               : chr  "Female" "Female" "Male" "Male" ...
\end{verbatim}

This gives several bits of information: how many rows (262) and columns
(18) are in the data, what each of these columns are called (parity,
age\_days and so on), and the values corresponding to the first few rows
of each variable. But the most important information is how these
variables are being stored - each variable will have one of the
following after the name:

\begin{itemize}
\item
  num: This variable is numeric, so we can do things that are relevant
  to either continuous or discrete variables like take the mean, range
  etc. This can also be called integer (int) or double (dbl) but you can
  think of these as being the same thing as numeric.
\item
  chr: This variable is a character, or text string. Variables are often
  read in as text, but this is actually not a very useful format so we
  usually want to convert these into something else (see the next
  section).
\item
  Factor: This variable is a factor, which is what R uses to represent
  categorical data. A factor is a very useful format that we will be
  using a lot. A closely related format is Ord.factor, which means that
  the order of the factor levels is meaningful: this is how R represents
  ordinal data.
\item
  POSIXct: This variable is a date time object, although the format may
  be shown as simply the date (in which case the time is implicitly
  00:00). This is also sometimes called `dttm'. If we have a column
  formatted either as a date or a time in Excel, then the variable will
  end up as POSIXct in R. Dealing with date times can be difficult as we
  can be caught out by time zones.
\item
  Date: This variable is a simpler representation of a Date, without an
  associated time. These are typically much easier to deal with than
  POSIXct variables.
\item
  logi: This variable takes the values FALSE or TRUE (logical).
\end{itemize}

Note that we only have numeric and character variables when reading in
the fetuses dataset. As a general rule, the output of read\_excel (or
read\_csv for a CSV file) will give us variables that are either numbers
if all of the values can be interpreted as a number, or text if any of
the variables can't be interpreted as a number (the main exception to
this is that read\_excel will automatically read columns formatted as
date or time in Excel into POSIXct). Blank cells do not count when
determining variable types, so if you have a column of numbers with some
empty cells then the variable will still be a number, just with some
missing values corresponding to the empty rows. Missing values in R are
represented by NA - but you should not use the text `NA' in Excel
(unless of course you want to represent sodium or Nebraska). If you have
values that are missing, just leave the cell blank.

Another way of looking at the data is by typing the name of the data
frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 262 x 18
##    parity age_days weight_kg crl_cm head_width_mm head_length_mm
##     <dbl>    <dbl>     <dbl>  <dbl>         <dbl>          <dbl>
##  1      3      274    35.5     86.8         128            239  
##  2      2      196    10.2     61.8          83.8          154  
##  3      1      259    27.2     89.3         121            220. 
##  4      1      249    29.1     83           118            215  
##  5      2      221    16.6     75.4         101.           183  
##  6      3      221    19.0     77.7          97            189  
##  7      2      177     6.35    55.4          74.5          142. 
##  8      2       82     0.046   10.4          24.3           36.8
##  9      6      193    11.2     62.4          85.4          153. 
## 10      4      142     1.77    35.4          62.4           99.8
## # ... with 252 more rows, and 12 more variables: hair_coronary_band <chr>,
## #   hair_ear <chr>, hair_eyelid <chr>, hair_tail <chr>, hair_hornbud <chr>,
## #   tactile_muzzle <chr>, tactile_eyebrow <chr>, tactile_eyelash <chr>,
## #   eye_op_close <chr>, papillae_tongue <chr>, eyelid <chr>, sex <chr>
\end{verbatim}

This shows the first few rows of data, but only for the first few
variables, so it is usually better to use the str() function. Notice
also that this method shows `dbl' (and sometimes `int') rather than
`num' for the numbers - but these are basically all the same thing.

Finally, we can use the summary() function to see summary statistics for
each variable:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}\StringTok{ }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      parity         age_days        weight_kg           crl_cm      
##  Min.   :1.000   Min.   : 25.00   Min.   : 0.0010   Min.   :  2.00  
##  1st Qu.:2.000   1st Qu.: 95.25   1st Qu.: 0.2537   1st Qu.: 18.30  
##  Median :3.000   Median :136.00   Median : 1.7805   Median : 35.65  
##  Mean   :2.752   Mean   :136.06   Mean   : 5.0029   Mean   : 37.90  
##  3rd Qu.:4.000   3rd Qu.:175.00   3rd Qu.: 6.9250   3rd Qu.: 54.60  
##  Max.   :6.000   Max.   :274.00   Max.   :41.6000   Max.   :101.30  
##  head_width_mm    head_length_mm   hair_coronary_band   hair_ear        
##  Min.   :  3.00   Min.   :  5.00   Length:262         Length:262        
##  1st Qu.: 39.24   1st Qu.: 55.52   Class :character   Class :character  
##  Median : 63.33   Median :101.28   Mode  :character   Mode  :character  
##  Mean   : 62.34   Mean   :103.29                                        
##  3rd Qu.: 84.02   3rd Qu.:145.54                                        
##  Max.   :152.00   Max.   :239.00                                        
##  hair_eyelid         hair_tail         hair_hornbud       tactile_muzzle    
##  Length:262         Length:262         Length:262         Length:262        
##  Class :character   Class :character   Class :character   Class :character  
##  Mode  :character   Mode  :character   Mode  :character   Mode  :character  
##                                                                             
##                                                                             
##                                                                             
##  tactile_eyebrow    tactile_eyelash    eye_op_close       papillae_tongue   
##  Length:262         Length:262         Length:262         Length:262        
##  Class :character   Class :character   Class :character   Class :character  
##  Mode  :character   Mode  :character   Mode  :character   Mode  :character  
##                                                                             
##                                                                             
##                                                                             
##     eyelid              sex           
##  Length:262         Length:262        
##  Class :character   Class :character  
##  Mode  :character   Mode  :character  
##                                       
##                                       
## 
\end{verbatim}

For the numeric variables (and any date/time variables), we get the
range (min and max), as well as median/mean and 1st and 3rd quantiles of
the variable. This is useful to check for extreme values that probably
indicate a data entry error. For factors, we get a count of how many
observations fall within each category. For the text variables, we don't
get any useful information: this is because there is no general way to
summarise text variables.

All this discussion of variable types is quite boring, but it is also
\textbf{very important}. There is a big difference in R between the text
`12.4' and the number 12.4, and between the text `2010-04-12' and the
date this represents, and between the text `male' and a factor with
observed level `male'. The format of the variable will affect the way in
which R does almost everything with that variable, from stratifying in
summaries and plots to handling explanatory variables in models. If the
formats are correct then everything will work the way we intended. If
the formats are incorrect then we will either get weird error messages
that we do not understand, or even worse: no error messages but totally
misleading results. So it is essential to spend the time making sure
that ALL formats of variables in our data frame are correct before
trying to analyse the data. Therefore, always follow the same procedure
when working with data in R:

\begin{enumerate}
\def\labelenumi{\arabic{enumi})}
\tightlist
\item
  Load tidyverse
\item
  Set your working directory in R
\item
  Read the data into a data frame in R (typically using either
  read\_excel or read\_csv)
\item
  Examine the formats of the variables within your data frame using
  str() and decide which variables can be discarded, which are already
  in the correct format, and which need to be converted into a different
  format
\item
  Modify your data frame so that all variables you want to keep are in
  the correct format (we will demonstrate how to do this below)
\item
  Re-examine the structure of your data frame using str() to ensure that
  everything has worked as expected
\item
  Examine summary statistics of the data using summary() and basic
  plots, to ensure that you do not have any strange values that might
  indicate data entry errors or other problems with your dataset
\item
  Carry on with your analysis safe in the knowledge that your data is
  correct!
\end{enumerate}

Steps 4-7 can be quite boring, but they are also \textbf{very important}
\ldots{} and it is always better to spend time checking that your data
is correct now rather than wasting time on incorrect analyses later on.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{creating-new-variables}{%
\subsubsection{Creating new variables}\label{creating-new-variables}}

In order to be able to format our variables correctly, we need to modify
the data frame we have created. Note that we do NOT want to modify the
original Excel file, only the data frame within R. There are several
ways to do this, but here we will stick with the tidyverse approach.

There is a very useful function called mutate() that allows us to create
a new variable based on one or more existing variables within a data
frame. For example, the following code creates a new numeric variable
called crl\_mm based on the existing numeric variable crl\_cm:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{crl_mm =}\NormalTok{ crl_cm}\OperatorTok{*}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 262 x 19
##    parity age_days weight_kg crl_cm head_width_mm head_length_mm
##     <dbl>    <dbl>     <dbl>  <dbl>         <dbl>          <dbl>
##  1      3      274    35.5     86.8         128            239  
##  2      2      196    10.2     61.8          83.8          154  
##  3      1      259    27.2     89.3         121            220. 
##  4      1      249    29.1     83           118            215  
##  5      2      221    16.6     75.4         101.           183  
##  6      3      221    19.0     77.7          97            189  
##  7      2      177     6.35    55.4          74.5          142. 
##  8      2       82     0.046   10.4          24.3           36.8
##  9      6      193    11.2     62.4          85.4          153. 
## 10      4      142     1.77    35.4          62.4           99.8
## # ... with 252 more rows, and 13 more variables: hair_coronary_band <chr>,
## #   hair_ear <chr>, hair_eyelid <chr>, hair_tail <chr>, hair_hornbud <chr>,
## #   tactile_muzzle <chr>, tactile_eyebrow <chr>, tactile_eyelash <chr>,
## #   eye_op_close <chr>, papillae_tongue <chr>, eyelid <chr>, sex <chr>,
## #   crl_mm <dbl>
\end{verbatim}

There are three things to note here:

\begin{itemize}
\item
  A new line and tab was entered between the chaining operator
  \%\textgreater\% and the function we are using: this is just to make
  the code easier to read by separating each part of the code onto a new
  line rather than having a single, very long line of code
\item
  This is a very simple mutate where we create a new variable called
  crl\_mm and calculate its values by multiplying the existing variable
  crl\_cm by 10. This creates a new column within the data frame because
  we do not already have a variable called `crl\_mm'. \textbf{If you
  reuse an existing variable name (e.g.~crl\_mm) then this will replace
  the previous column within the data frame}.
\item
  The mutate function creates a new data frame, but we have not assigned
  it to anything - so R just shows us the new data frame (which is
  identical to the old one except for having 19 rather than 18
  variables) and then immediately forgets it.
\end{itemize}

To get R to remember the changes we are making to the data frame we need
to assign it to something using the assignment operator. For example,
this code creates a new data frame called fetuses\_full:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses_full <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{crl_mm =}\NormalTok{ crl_cm}\OperatorTok{*}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You should now see a new data frame called fetuses\_full appear in your
R environment as `262 obs. of 19 variables'. Rather than creating new
data frames every time we add a new variable, we might want to
over-write the existing data frame instead. In this case, we can just
assign the new data frame to have the same name as the old one:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{crl_mm =}\NormalTok{ crl_cm}\OperatorTok{*}\DecValTok{10}\NormalTok{)}

\NormalTok{fetuses }\OperatorTok{%>%}\StringTok{ }
\StringTok{    }\KeywordTok{str}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Classes 'tbl_df', 'tbl' and 'data.frame':    262 obs. of  19 variables:
##  $ parity            : num  3 2 1 1 2 3 2 2 6 4 ...
##  $ age_days          : num  274 196 259 249 221 221 177 82 193 142 ...
##  $ weight_kg         : num  35.5 10.2 27.1 29.1 16.6 ...
##  $ crl_cm            : num  86.8 61.8 89.3 83 75.4 77.7 55.4 10.4 62.4 35.4 ...
##  $ head_width_mm     : num  128 83.8 121 118 100.6 ...
##  $ head_length_mm    : num  239 154 220 215 183 ...
##  $ hair_coronary_band: chr  "Y" "Y" "Y" "Y" ...
##  $ hair_ear          : chr  "Y" "Y" "Y" "Y" ...
##  $ hair_eyelid       : chr  "Y" "Y" "Y" "Y" ...
##  $ hair_tail         : chr  "Y" "Y" "Y" "Y" ...
##  $ hair_hornbud      : chr  "Y" "Y" "Y" "Y" ...
##  $ tactile_muzzle    : chr  "Visible" "Visible" "Visible" "Visible" ...
##  $ tactile_eyebrow   : chr  "Visible" "Visible" "Visible" "Visible" ...
##  $ tactile_eyelash   : chr  "Visible" "Visible" "Visible" "Visible" ...
##  $ eye_op_close      : chr  "Open" "Open" "Open" "Open" ...
##  $ papillae_tongue   : chr  "Whole tongue" "Whole tongue" "Whole tongue" "Whole tongue" ...
##  $ eyelid            : chr  "Y" "Y" "Y" "Y" ...
##  $ sex               : chr  "Female" "Female" "Male" "Male" ...
##  $ crl_mm            : num  868 618 893 830 754 777 554 104 624 354 ...
\end{verbatim}

The first line of this code is a very common pattern that we will use
repeatedly - it tells R to save a data frame called `fetuses' which is
based on an existing data frame called `fetuses' but with some
function(s) (given on additional lines) applied to it using the chaining
operator. But remember that if we over-write the existing data frame
with something that we did not intend to due to a mistake in our code,
then we will not be able to simply correct the mistake in the code and
re-run that single line. Instead we will have to run the whole data
handling code again from the beginning up to the point just before we
made the mistake.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{selecting-and-filtering-columns-or-rows}{%
\subsubsection{Selecting and filtering columns or
rows}\label{selecting-and-filtering-columns-or-rows}}

Sometimes we might be reading in a large Excel dataset (with many
columns and/or rows), but we do not want to work with the whole dataset.
For example, let's say we are only interested in the parity, age and
hair\_coronary\_band variables in the fetuses data frame. Rather than
working on the large dataset, it might be a good idea to create a second
data frame with a more restricted dataset - this will be easier (and
faster) to work with, but does not remove any information from the
original dataset that we have already copied to fetuses\_full. We can
select columns from fetuses (and over-write this data frame) using the
select() function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{select}\NormalTok{(parity, age_days, hair_coronary_band)}
\end{Highlighting}
\end{Shaded}

You should now see that fetuses is 262 obs. or 3 variables (but
fetuses\_full is still 19 variables so we still have the original data).
This makes it easier to look only at what we want:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      parity         age_days      hair_coronary_band
##  Min.   :1.000   Min.   : 25.00   Length:262        
##  1st Qu.:2.000   1st Qu.: 95.25   Class :character  
##  Median :3.000   Median :136.00   Mode  :character  
##  Mean   :2.752   Mean   :136.06                     
##  3rd Qu.:4.000   3rd Qu.:175.00                     
##  Max.   :6.000   Max.   :274.00
\end{verbatim}

We might even go further, and want to exclude the very early fetuses
from the dataset we are working with. The filter() function extracts
only rows that meet one or more conditions, e.g.:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{filter}\NormalTok{(age_days }\OperatorTok{>=}\StringTok{ }\DecValTok{50}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Now we have only the 243 obs. from fetuses with a gestational age of 50
days or more.

The great thing about the chaining operator is that it is easy to do
multiple functions in a row without stopping in between, for example the
two bits of R code above is the same as the following single piece of R
code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses_full }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{select}\NormalTok{(parity, age_days, hair_coronary_band) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{filter}\NormalTok{(age_days }\OperatorTok{>=}\StringTok{ }\DecValTok{50}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Note that we can add as many functions to the chain as we want to, as
long as we remember to put \%\textgreater\% at the end of every function
(except the last function - this terminates the chain). Let's add
another function near the top of this chain using mutate to create a new
variable that tells us the row number from the original data that each
row in the filtered data corresponds to (just in case we need it later):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses_full }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{ID =} \KeywordTok{row_number}\NormalTok{()) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{select}\NormalTok{(ID, parity, age_days, hair_coronary_band) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{filter}\NormalTok{(age_days }\OperatorTok{>=}\StringTok{ }\DecValTok{50}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You can see now why it is a good idea to put each function on a new line
- otherwise the code would quickly get hard to read! As long as the
\%\textgreater\% operator comes at the end of the line (rather than at
the start of the new line), then it all works as expected. Remember that
all the code within the chain (even if on multiple lines) is a single R
command, so it will not work if you try to just run the last line (for
example). Fortunately, RStudio is smart enough to know this and will run
the entire command if the curser is anywhere on any of the lines within
the whole chain of functions.

An important feature of these code chains is that they are run in
sequence from top to bottom. Therefore, if we both create a variable and
do something with this same variable within a chain, then we have to
make sure that the function that creates the variable appears before any
functions using this variable. For example, the following code will not
work because ID is selected before it is created:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses_full }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{select}\NormalTok{(ID, parity, age_days, hair_coronary_band) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{ID =} \KeywordTok{row_number}\NormalTok{()) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{filter}\NormalTok{(age_days }\OperatorTok{>=}\StringTok{ }\DecValTok{50}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Error: Can't subset columns that don't exist.
## [31mx[39m The column `ID` doesn't exist.
\end{verbatim}

Notice that the select function gives us variables in the order that we
asked for them. Therefore, we can also use it to re-order the columns of
a data frame by typing all of the variable names but in a different
sequence:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{str}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Classes 'tbl_df', 'tbl' and 'data.frame':    243 obs. of  4 variables:
##  $ ID                : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ parity            : num  3 2 1 1 2 3 2 2 6 4 ...
##  $ age_days          : num  274 196 259 249 221 221 177 82 193 142 ...
##  $ hair_coronary_band: chr  "Y" "Y" "Y" "Y" ...
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{select}\NormalTok{(parity, ID, age_days, hair_coronary_band) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{str}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Classes 'tbl_df', 'tbl' and 'data.frame':    243 obs. of  4 variables:
##  $ parity            : num  3 2 1 1 2 3 2 2 6 4 ...
##  $ ID                : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ age_days          : num  274 196 259 249 221 221 177 82 193 142 ...
##  $ hair_coronary_band: chr  "Y" "Y" "Y" "Y" ...
\end{verbatim}

We can also use one or more `select helper' functions to select groups
of variables rather than typing out the variable names individually. The
most useful of these are starts\_with(), contains(), and everything() -
for example the following code selects ID first, then anything starting
with `crl', then anything containing `eye', then everything else:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses_full }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{ID =} \KeywordTok{row_number}\NormalTok{()) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{select}\NormalTok{(ID, }\KeywordTok{starts_with}\NormalTok{(}\StringTok{'crl'}\NormalTok{), }\KeywordTok{contains}\NormalTok{(}\StringTok{'eye'}\NormalTok{), }\KeywordTok{everything}\NormalTok{()) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{str}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Classes 'tbl_df', 'tbl' and 'data.frame':    262 obs. of  20 variables:
##  $ ID                : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ crl_cm            : num  86.8 61.8 89.3 83 75.4 77.7 55.4 10.4 62.4 35.4 ...
##  $ crl_mm            : num  868 618 893 830 754 777 554 104 624 354 ...
##  $ hair_eyelid       : chr  "Y" "Y" "Y" "Y" ...
##  $ tactile_eyebrow   : chr  "Visible" "Visible" "Visible" "Visible" ...
##  $ tactile_eyelash   : chr  "Visible" "Visible" "Visible" "Visible" ...
##  $ eye_op_close      : chr  "Open" "Open" "Open" "Open" ...
##  $ eyelid            : chr  "Y" "Y" "Y" "Y" ...
##  $ parity            : num  3 2 1 1 2 3 2 2 6 4 ...
##  $ age_days          : num  274 196 259 249 221 221 177 82 193 142 ...
##  $ weight_kg         : num  35.5 10.2 27.1 29.1 16.6 ...
##  $ head_width_mm     : num  128 83.8 121 118 100.6 ...
##  $ head_length_mm    : num  239 154 220 215 183 ...
##  $ hair_coronary_band: chr  "Y" "Y" "Y" "Y" ...
##  $ hair_ear          : chr  "Y" "Y" "Y" "Y" ...
##  $ hair_tail         : chr  "Y" "Y" "Y" "Y" ...
##  $ hair_hornbud      : chr  "Y" "Y" "Y" "Y" ...
##  $ tactile_muzzle    : chr  "Visible" "Visible" "Visible" "Visible" ...
##  $ papillae_tongue   : chr  "Whole tongue" "Whole tongue" "Whole tongue" "Whole tongue" ...
##  $ sex               : chr  "Female" "Female" "Male" "Male" ...
\end{verbatim}

If a select helper matches several variables then these are given in the
same order as they were found in the original data frame, so for example
hair\_eyelid appears before tactile\_eyebrow because they both contain
`eye' but hair\_eyelid came first in fetuses\_full.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{converting-text-variables-into-factors}{%
\subsubsection{Converting text variables into
factors}\label{converting-text-variables-into-factors}}

When reading Excel files, R will usually store numbers (and date/time
variables) into the correct format automatically (unless these columns
include some cells with text entries in Excel). But it has no way of
reliably formatting our categorical data automatically, so we need to
manually convert them into factor variables using `parse\_factor' within
a mutate function to convert a character/text variable to a factor. For
example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_coronary_band_fct =} \KeywordTok{parse_factor}\NormalTok{(hair_coronary_band))}
\end{Highlighting}
\end{Shaded}

This creates a new variable by turning the text variable
hair\_coronary\_band into a factor. We can now summarise this more
usefully than we could with the text variable:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        ID            parity         age_days     hair_coronary_band
##  Min.   :  1.0   Min.   :1.000   Min.   : 51.0   Length:243        
##  1st Qu.: 61.5   1st Qu.:2.000   1st Qu.:107.5   Class :character  
##  Median :122.0   Median :3.000   Median :144.0   Mode  :character  
##  Mean   :125.6   Mean   :2.774   Mean   :143.3                     
##  3rd Qu.:188.5   3rd Qu.:4.000   3rd Qu.:176.5                     
##  Max.   :262.0   Max.   :6.000   Max.   :274.0                     
##  hair_coronary_band_fct
##  Y: 60                 
##  N:183                 
##                        
##                        
##                        
## 
\end{verbatim}

Now we get the number of Y and the number of N for
hair\_coronary\_band\_fct. In this case, that works OK - but what would
happen if the data had been entered inconsistently, for example if `n'
had sometimes been used instead of `N'? Let's deliberately introduce an
error (don't worry about the code itself - you won't do this in real
life!):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses}\OperatorTok{$}\NormalTok{hair_coronary_band[}\DecValTok{1}\NormalTok{] <-}\StringTok{ 'n'}
\end{Highlighting}
\end{Shaded}

We can see the first observation in hair\_coronary\_band is now `n':

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}\StringTok{ }\KeywordTok{str}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Classes 'tbl_df', 'tbl' and 'data.frame':    243 obs. of  5 variables:
##  $ ID                    : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ parity                : num  3 2 1 1 2 3 2 2 6 4 ...
##  $ age_days              : num  274 196 259 249 221 221 177 82 193 142 ...
##  $ hair_coronary_band    : chr  "n" "Y" "Y" "Y" ...
##  $ hair_coronary_band_fct: Factor w/ 2 levels "Y","N": 1 1 1 1 1 1 1 2 1 2 ...
\end{verbatim}

What happens when this is automatically turned into a factor?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_coronary_band_fct =} \KeywordTok{parse_factor}\NormalTok{(hair_coronary_band))}

\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        ID            parity         age_days     hair_coronary_band
##  Min.   :  1.0   Min.   :1.000   Min.   : 51.0   Length:243        
##  1st Qu.: 61.5   1st Qu.:2.000   1st Qu.:107.5   Class :character  
##  Median :122.0   Median :3.000   Median :144.0   Mode  :character  
##  Mean   :125.6   Mean   :2.774   Mean   :143.3                     
##  3rd Qu.:188.5   3rd Qu.:4.000   3rd Qu.:176.5                     
##  Max.   :262.0   Max.   :6.000   Max.   :274.0                     
##  hair_coronary_band_fct
##  n:  1                 
##  Y: 59                 
##  N:183                 
##                        
##                        
## 
\end{verbatim}

There are now 3 factor levels in hair\_coronary\_band\_fct: Y, N and
n.~Note that N and n are different, but we don't really want them to be!
We can deal with this by first creating the factor as before, and
chaining the data frame into a second mutate where we use fct\_collapse
to manually recode the factor levels so that Y becomes Yes and both n
and N become No, like so:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_coronary_band_fct =} \KeywordTok{parse_factor}\NormalTok{(hair_coronary_band)) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_coronary_band_fct =} \KeywordTok{fct_collapse}\NormalTok{(hair_coronary_band_fct, }
                                             \DataTypeTok{No =} \KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{, }\StringTok{'n'}\NormalTok{), }\DataTypeTok{Yes=}\StringTok{'Y'}\NormalTok{))}

\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        ID            parity         age_days     hair_coronary_band
##  Min.   :  1.0   Min.   :1.000   Min.   : 51.0   Length:243        
##  1st Qu.: 61.5   1st Qu.:2.000   1st Qu.:107.5   Class :character  
##  Median :122.0   Median :3.000   Median :144.0   Mode  :character  
##  Mean   :125.6   Mean   :2.774   Mean   :143.3                     
##  3rd Qu.:188.5   3rd Qu.:4.000   3rd Qu.:176.5                     
##  Max.   :262.0   Max.   :6.000   Max.   :274.0                     
##  hair_coronary_band_fct
##  No :184               
##  Yes: 59               
##                        
##                        
##                        
## 
\end{verbatim}

Notice also that the factor levels have swapped around; No is now the
reference category because this came first in the arguments to the
fct\_collapse function. This will be important later on, when the data
need to be used for modelling.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{specifying-factor-levels}{%
\subsubsection{Specifying factor
levels}\label{specifying-factor-levels}}

In the real world, we do not want to spend time examining all of the
factors to make sure that there aren't any typos - particularly when we
think the data should be correct to start with! This can lead to errors,
because we might not check as carefully as we should and therefore miss
problems with the data. So it is much better practice to tell
parse\_factor what to expect by using the levels argument:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_coronary_band_fct =} \KeywordTok{parse_factor}\NormalTok{(hair_coronary_band, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{,}\StringTok{'Y'}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: 1 parsing failure.
## row col           expected actual
##   1  -- value in level set      n
\end{verbatim}

When we run this code, we get a warning to tell us that an unexpected
text entry `n' was observed in row 1, and the resulting variable now has
1 missing value (NA):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        ID            parity         age_days     hair_coronary_band
##  Min.   :  1.0   Min.   :1.000   Min.   : 51.0   Length:243        
##  1st Qu.: 61.5   1st Qu.:2.000   1st Qu.:107.5   Class :character  
##  Median :122.0   Median :3.000   Median :144.0   Mode  :character  
##  Mean   :125.6   Mean   :2.774   Mean   :143.3                     
##  3rd Qu.:188.5   3rd Qu.:4.000   3rd Qu.:176.5                     
##  Max.   :262.0   Max.   :6.000   Max.   :274.0                     
##  hair_coronary_band_fct
##  N   :183              
##  Y   : 59              
##  NA's:  1              
##                        
##                        
## 
\end{verbatim}

This is good because R has automatically alerted us to a problem that we
need to fix. So we can go back and adjust our code so it looks like
this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_coronary_band_fct =} 
             \KeywordTok{parse_factor}\NormalTok{(hair_coronary_band, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{,}\StringTok{'n'}\NormalTok{,}\StringTok{'Y'}\NormalTok{))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_coronary_band_fct =} 
             \KeywordTok{fct_collapse}\NormalTok{(hair_coronary_band_fct, }\DataTypeTok{No =} \KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{, }\StringTok{'n'}\NormalTok{), }\DataTypeTok{Yes=}\StringTok{'Y'}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

This tells R to expect the `n' entry, but then immediately re-codes it
afterwards - this approach will fix known problems in the data, but
still automatically alert us to any new problems that might occur if
e.g.~we update the data to include more observations (and different
mistakes!).

There is one additional thing to remember with parse\_factor: if there
were observations in the original data that were missing before making
them into a factor, then these will be treated differently to
observations that were present but corresponded to unknown factor
levels. For example, let's deliberately make the second observation of
hair\_coronary\_band blank (i.e.~missing) and then re-run the code with
only N and Y as specified levels:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses}\OperatorTok{$}\NormalTok{hair_coronary_band[}\DecValTok{2}\NormalTok{] <-}\StringTok{ ''}

\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_coronary_band_fct =} \KeywordTok{parse_factor}\NormalTok{(hair_coronary_band, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{,}\StringTok{'Y'}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: 1 parsing failure.
## row col           expected actual
##   1  -- value in level set      n
\end{verbatim}

We get the red text again (telling us about the `n' on row 1), but no
mention of the missing entry on row 2. This is because parse\_factor has
created an explicit factor level for missing data:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        ID            parity         age_days     hair_coronary_band
##  Min.   :  1.0   Min.   :1.000   Min.   : 51.0   Length:243        
##  1st Qu.: 61.5   1st Qu.:2.000   1st Qu.:107.5   Class :character  
##  Median :122.0   Median :3.000   Median :144.0   Mode  :character  
##  Mean   :125.6   Mean   :2.774   Mean   :143.3                     
##  3rd Qu.:188.5   3rd Qu.:4.000   3rd Qu.:176.5                     
##  Max.   :262.0   Max.   :6.000   Max.   :274.0                     
##  hair_coronary_band_fct
##  N   :183              
##  Y   : 58              
##  NA  :  1              
##  NA's:  1              
##                        
## 
\end{verbatim}

We have both the factor level NA (the value that was missing to start
with) and NA's (the value of `n' that became missing because it wasn't
included in the allowed levels). But this subtle distinction is not
visible in the data itself:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 243 x 5
##       ID parity age_days hair_coronary_band hair_coronary_band_fct
##    <int>  <dbl>    <dbl> <chr>              <fct>                 
##  1     1      3      274 "n"                <NA>                  
##  2     2      2      196 ""                 <NA>                  
##  3     3      1      259 "Y"                Y                     
##  4     4      1      249 "Y"                Y                     
##  5     5      2      221 "Y"                Y                     
##  6     6      3      221 "Y"                Y                     
##  7     7      2      177 "Y"                Y                     
##  8     8      2       82 "N"                N                     
##  9     9      6      193 "Y"                Y                     
## 10    10      4      142 "N"                N                     
## # ... with 233 more rows
\end{verbatim}

Having this distinction can sometimes be useful, but if we want to
remove the NA factor level then we can specify the include\_na = FALSE
argument e.g.:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_coronary_band_fct =} 
             \KeywordTok{parse_factor}\NormalTok{(hair_coronary_band, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{,}\StringTok{'Y'}\NormalTok{), }\DataTypeTok{include_na =} \OtherTok{FALSE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Warning: 1 parsing failure.
## row col           expected actual
##   1  -- value in level set      n
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        ID            parity         age_days     hair_coronary_band
##  Min.   :  1.0   Min.   :1.000   Min.   : 51.0   Length:243        
##  1st Qu.: 61.5   1st Qu.:2.000   1st Qu.:107.5   Class :character  
##  Median :122.0   Median :3.000   Median :144.0   Mode  :character  
##  Mean   :125.6   Mean   :2.774   Mean   :143.3                     
##  3rd Qu.:188.5   3rd Qu.:4.000   3rd Qu.:176.5                     
##  Max.   :262.0   Max.   :6.000   Max.   :274.0                     
##  hair_coronary_band_fct
##  N   :183              
##  Y   : 58              
##  NA's:  2              
##                        
##                        
## 
\end{verbatim}

Now there is no distinction between the blank entry and the entry that
was originally `n' - they are both NA's. Alternatively, you can remove
the NA factor level (or any other factor level that you want to) by
setting it to NULL within fct\_collapse:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_coronary_band =} 
             \KeywordTok{parse_factor}\NormalTok{(hair_coronary_band, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{,}\StringTok{'n'}\NormalTok{,}\StringTok{'Y'}\NormalTok{))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_coronary_band =} 
             \KeywordTok{fct_collapse}\NormalTok{(hair_coronary_band, }\DataTypeTok{NULL =} \StringTok{'NA'}\NormalTok{, }\DataTypeTok{No =} \KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{, }\StringTok{'n'}\NormalTok{), }\DataTypeTok{Yes=}\StringTok{'Y'}\NormalTok{))}

\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        ID            parity         age_days     hair_coronary_band
##  Min.   :  1.0   Min.   :1.000   Min.   : 51.0   No  :184          
##  1st Qu.: 61.5   1st Qu.:2.000   1st Qu.:107.5   Yes : 58          
##  Median :122.0   Median :3.000   Median :144.0   NA's:  1          
##  Mean   :125.6   Mean   :2.774   Mean   :143.3                     
##  3rd Qu.:188.5   3rd Qu.:4.000   3rd Qu.:176.5                     
##  Max.   :262.0   Max.   :6.000   Max.   :274.0                     
##  hair_coronary_band_fct
##  N   :183              
##  Y   : 58              
##  NA's:  2              
##                        
##                        
## 
\end{verbatim}

Notice this time that I have replaced the existing variable
hair\_coronary\_band rather than creating a new variable - generally we
will want to do this when creating factors, as the original text entries
are no longer needed. This has destroyed the original text variable
though, so we will not be able to re-run this line of code without
running the entire R code from the beginning: the easiest way to do this
is by clicking on source.

The only difference between the factors hair\_coronary\_band and
hair\_coronary\_band\_fct is that `n' was made into `No' in
hair\_coronary\_band, but left as missing in hair\_coronary\_band\_fct.
Other than for demonstration purposes we don't really need
hair\_coronary\_band\_fct, so it is best to remove it - we can do this
using select and a minus symbol in front of the variable name to
indicate it is to be removed rather than retained:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{select}\NormalTok{(}\OperatorTok{-}\NormalTok{hair_coronary_band_fct)}

\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{str}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Classes 'tbl_df', 'tbl' and 'data.frame':    243 obs. of  4 variables:
##  $ ID                : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ parity            : num  3 2 1 1 2 3 2 2 6 4 ...
##  $ age_days          : num  274 196 259 249 221 221 177 82 193 142 ...
##  $ hair_coronary_band: Factor w/ 2 levels "No","Yes": 1 NA 2 2 2 2 2 1 2 1 ...
\end{verbatim}

Now we have 4 variables: ID, parity, age\_days and hair\_coronary\_band
as a factor with No/Yes recordings (and one missing observation i.e.~the
missing value we created on row 2).

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{section-2-working-with-different-variable-types}{%
\subsection{Section 2: working with different variable
types}\label{section-2-working-with-different-variable-types}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{converting-numbers-into-factors}{%
\subsubsection{Converting numbers into
factors}\label{converting-numbers-into-factors}}

Most of the time we will be creating factors from text entries, but
occasionally we will want to create factors from numbers. The best
approach to use depends on whether the number is a discrete number
(i.e.~whole numbers only), or a continuous number. Let us take them one
at a time.

For \textbf{discrete numbers}, we can use the parse\_factor() function
like before - but we first need to turn the integer into a character
(text) variable. It is also a good idea to add some text to the number
so that the resulting factor is more easily distinguishable from a `true
number'. We can accomplish both tasks simultaneously using the str\_c()
function, for example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{parity_text =} \KeywordTok{str_c}\NormalTok{(}\StringTok{'Parity_'}\NormalTok{, parity)) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{parity_fct =} \KeywordTok{parse_factor}\NormalTok{(parity_text)) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{str}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Classes 'tbl_df', 'tbl' and 'data.frame':    243 obs. of  6 variables:
##  $ ID                : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ parity            : num  3 2 1 1 2 3 2 2 6 4 ...
##  $ age_days          : num  274 196 259 249 221 221 177 82 193 142 ...
##  $ hair_coronary_band: Factor w/ 2 levels "No","Yes": 1 NA 2 2 2 2 2 1 2 1 ...
##  $ parity_text       : chr  "Parity_3" "Parity_2" "Parity_1" "Parity_1" ...
##  $ parity_fct        : Factor w/ 6 levels "Parity_3","Parity_2",..: 1 2 3 3 2 1 2 2 4 5 ...
\end{verbatim}

This has been broken down into stages so that you can see what is going
on. The first step uses str\_c() to create a new character variable by
sticking the text `Parity\_' before the parity number, and the second
step creates a factor from the character variable as we did before. The
only problem with this is that we haven't specified levels to
parse\_factor(), so if we have any errors in the data (e.g.~a negative
number for parity) then we will not detect these. A good trick is to
automatically create a wide range of possible parity levels without
having to type them all out:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_c}\NormalTok{(}\StringTok{'Parity_'}\NormalTok{, }\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from=}\DecValTok{1}\NormalTok{, }\DataTypeTok{to=}\DecValTok{10}\NormalTok{, }\DataTypeTok{by=}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "Parity_1"  "Parity_2"  "Parity_3"  "Parity_4"  "Parity_5"  "Parity_6" 
##  [7] "Parity_7"  "Parity_8"  "Parity_9"  "Parity_10"
\end{verbatim}

The seq() function creates all possible numbers between from (1) and to
(10), with increments of by (1). If you already knew that the range was
narrower (for example only parities 1 to 6 were observed) then you could
adjust the code accordingly - we will discuss a way to check this later
on.

We can then use our generated parity levels in the parse\_factor
function, and combine all steps of the code together:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{parity_fct =} \KeywordTok{parse_factor}\NormalTok{(}\KeywordTok{str_c}\NormalTok{(}\StringTok{'Parity_'}\NormalTok{, parity), }
        \DataTypeTok{levels=}\KeywordTok{str_c}\NormalTok{(}\StringTok{'Parity_'}\NormalTok{, }\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from=}\DecValTok{1}\NormalTok{, }\DataTypeTok{to=}\DecValTok{10}\NormalTok{, }\DataTypeTok{by=}\DecValTok{1}\NormalTok{)))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{parity_group =} \KeywordTok{fct_collapse}\NormalTok{(parity_fct, }\DataTypeTok{First=}\StringTok{'Parity_1'}\NormalTok{, }\DataTypeTok{Second=}\StringTok{'Parity_2'}\NormalTok{, }
        \DataTypeTok{Older=}\KeywordTok{str_c}\NormalTok{(}\StringTok{'Parity_'}\NormalTok{, }\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from=}\DecValTok{3}\NormalTok{, }\DataTypeTok{to=}\DecValTok{9}\NormalTok{, }\DataTypeTok{by=}\DecValTok{1}\NormalTok{)), }\DataTypeTok{Ancient=}\StringTok{'Parity_10'}\NormalTok{))}

\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        ID            parity         age_days     hair_coronary_band
##  Min.   :  1.0   Min.   :1.000   Min.   : 51.0   No  :184          
##  1st Qu.: 61.5   1st Qu.:2.000   1st Qu.:107.5   Yes : 58          
##  Median :122.0   Median :3.000   Median :144.0   NA's:  1          
##  Mean   :125.6   Mean   :2.774   Mean   :143.3                     
##  3rd Qu.:188.5   3rd Qu.:4.000   3rd Qu.:176.5                     
##  Max.   :262.0   Max.   :6.000   Max.   :274.0                     
##                                                                    
##     parity_fct  parity_group
##  Parity_2:79   First  : 40  
##  Parity_3:56   Second : 79  
##  Parity_4:45   Older  :124  
##  Parity_1:40   Ancient:  0  
##  Parity_6:13                
##  Parity_5:10                
##  (Other) : 0
\end{verbatim}

This code looks quite complicated, but if you break it down into steps
you should be able to see what is going on. The first mutate function
just combines the separate steps we had before - first using str\_c() to
add the text `Parity\_' to the parity number, then parsing this into a
factor using specified levels. The second mutate function uses
fct\_collapse to create a second factor of parity\_group, where we
combine parities 3-9 into a single group.

Notice here that we specified a factor level that doesn't exist in the
data - there are no Parity\_10 cows (and therefore no Ancient cows). In
some situations this is helpful: we can include a possible factor level
and R will explictly tell us that there are no observations within that
category. But if we want to remove the unused factor levels, we can do
this using the fct\_drop function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{parity_fct =} \KeywordTok{fct_drop}\NormalTok{(parity_fct), }\DataTypeTok{parity_group =} \KeywordTok{fct_drop}\NormalTok{(parity_group))}

\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        ID            parity         age_days     hair_coronary_band
##  Min.   :  1.0   Min.   :1.000   Min.   : 51.0   No  :184          
##  1st Qu.: 61.5   1st Qu.:2.000   1st Qu.:107.5   Yes : 58          
##  Median :122.0   Median :3.000   Median :144.0   NA's:  1          
##  Mean   :125.6   Mean   :2.774   Mean   :143.3                     
##  3rd Qu.:188.5   3rd Qu.:4.000   3rd Qu.:176.5                     
##  Max.   :262.0   Max.   :6.000   Max.   :274.0                     
##     parity_fct parity_group
##  Parity_1:40   First : 40  
##  Parity_2:79   Second: 79  
##  Parity_3:56   Older :124  
##  Parity_4:45               
##  Parity_5:10               
##  Parity_6:13
\end{verbatim}

There is now no more mention of `Ancient' cows in parity\_group. Notice
here that rather than using two separate mutate() functions, I mutated
two variables within the same function separated by a comma. The two
approaches are the same.

There is a second discrete number that makes sense to convert into a
factor: our ID variable is currently stored as a number, but it makes
more sense to think of it as a grouping variable i.e.~a factor.
Sometimes this doesn't make any difference, but if we want to use ID
either to merge datasets, or as a stratifying variable in a plot or in a
model, then we might get the wrong result if ID is a number. So we had
better turn it into a factor:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{ID_simple =} \KeywordTok{parse_factor}\NormalTok{(}\KeywordTok{str_c}\NormalTok{(}\StringTok{'ID_'}\NormalTok{, ID)))  }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{ID =} \KeywordTok{parse_factor}\NormalTok{(}\KeywordTok{str_c}\NormalTok{(}\StringTok{'ID_'}\NormalTok{, }\KeywordTok{str_replace_all}\NormalTok{(}\KeywordTok{format}\NormalTok{(ID),}\StringTok{' '}\NormalTok{,}\StringTok{'0'}\NormalTok{))))}

\NormalTok{fetuses}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 243 x 7
##    ID     parity age_days hair_coronary_band parity_fct parity_group ID_simple
##    <fct>   <dbl>    <dbl> <fct>              <fct>      <fct>        <fct>    
##  1 ID_001      3      274 No                 Parity_3   Older        ID_1     
##  2 ID_002      2      196 <NA>               Parity_2   Second       ID_2     
##  3 ID_003      1      259 Yes                Parity_1   First        ID_3     
##  4 ID_004      1      249 Yes                Parity_1   First        ID_4     
##  5 ID_005      2      221 Yes                Parity_2   Second       ID_5     
##  6 ID_006      3      221 Yes                Parity_3   Older        ID_6     
##  7 ID_007      2      177 Yes                Parity_2   Second       ID_7     
##  8 ID_008      2       82 No                 Parity_2   Second       ID_8     
##  9 ID_009      6      193 Yes                Parity_6   Older        ID_9     
## 10 ID_010      4      142 No                 Parity_4   Older        ID_10    
## # ... with 233 more rows
\end{verbatim}

Two different methods are used here - the first simple method works
fine, but the resulting IDs are ID\_1, ID\_2, \ldots{} ID\_10, ID\_11,
\ldots{} ID\_99, ID\_100 etc. So when these are sorted alphabetically,
they end up in a different order to the numbers themselves. The second
method is slightly more complex but gives us ID numbers ID\_001,
ID\_002, \ldots{} ID\_010, ID\_011, \ldots{} ID\_099, ID\_100 etc so
that the order is preserved. If you are interested in how the format()
and str\_replace\_all() functions work, look at their help files by
typing ?format and ?str\_replace\_all in R.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

Turning \textbf{continous numbers into factors} uses a slightly
different method with the cut() function rather than parse\_string. The
cut function allows you to break a continuous variable into segments
using specified breakpoints and corresponding labels for the factor
levels. For example we can turn the age into a factor to reflect an
early, mid or late stage foetus:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{age_group =} 
         \KeywordTok{cut}\NormalTok{(age_days, }\DataTypeTok{breaks=}\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{200}\NormalTok{, }\DecValTok{300}\NormalTok{), }\DataTypeTok{labels=}\KeywordTok{c}\NormalTok{(}\StringTok{'Early'}\NormalTok{, }\StringTok{'Middle'}\NormalTok{, }\StringTok{'Late'}\NormalTok{)))}

\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        ID          parity         age_days     hair_coronary_band    parity_fct
##  ID_001 :  1   Min.   :1.000   Min.   : 51.0   No  :184           Parity_1:40  
##  ID_002 :  1   1st Qu.:2.000   1st Qu.:107.5   Yes : 58           Parity_2:79  
##  ID_003 :  1   Median :3.000   Median :144.0   NA's:  1           Parity_3:56  
##  ID_004 :  1   Mean   :2.774   Mean   :143.3                      Parity_4:45  
##  ID_005 :  1   3rd Qu.:4.000   3rd Qu.:176.5                      Parity_5:10  
##  ID_006 :  1   Max.   :6.000   Max.   :274.0                      Parity_6:13  
##  (Other):237                                                                   
##  parity_group   ID_simple    age_group  
##  First : 40   ID_1   :  1   Early : 54  
##  Second: 79   ID_2   :  1   Middle:159  
##  Older :124   ID_3   :  1   Late  : 30  
##               ID_4   :  1               
##               ID_5   :  1               
##               ID_6   :  1               
##               (Other):237
\end{verbatim}

The breaks argument must always specify the lowest and highest possible
values as the first and last numbers, so there is always one more group
label than there are breaks. By default the breaks define intervals that
are open on the left and closed on the right, so a number exactly equal
to a break goes into the category below this break. For example, here we
have categories defined as:

\begin{itemize}
\item
  \textbf{Early}: 0 \textless{} age \textless= 100 (including age = 100)
\item
  \textbf{Middle}: 100 \textless{} age \textless= 200 (including age =
  200)
\item
  \textbf{Late}: 200 \textless{} age \textless= 300 (including age =
  300)
\end{itemize}

Notice that an age of 0 is NOT included in the Early category: this
would be converted to a missing value in the factor along with any
values below 0 or above 300. If you want to include all possible values,
then you can specify the first and last breaks as -Inf and Inf - meaning
negative infinity and infinity.

We can also use the cut function with discrete numbers, although we have
to be even more careful about the rules for closed vs open intervals
because it will happen more often (for example, an age of exactly 100
days is far less likely than a parity of exactly 3). Alternatively, you
can specify the breaks as being mid-way between the discrete values to
make the code more obvious, for example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{parity_fct_cut =} \KeywordTok{cut}\NormalTok{(parity, }\DataTypeTok{breaks=}\KeywordTok{c}\NormalTok{(}\FloatTok{0.5}\NormalTok{, }\FloatTok{1.5}\NormalTok{, }\FloatTok{2.5}\NormalTok{, }\FloatTok{10.5}\NormalTok{), }
                                \DataTypeTok{labels=}\KeywordTok{c}\NormalTok{(}\StringTok{'First'}\NormalTok{,}\StringTok{'Second'}\NormalTok{,}\StringTok{'Older'}\NormalTok{)))}

\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        ID          parity         age_days     hair_coronary_band    parity_fct
##  ID_001 :  1   Min.   :1.000   Min.   : 51.0   No  :184           Parity_1:40  
##  ID_002 :  1   1st Qu.:2.000   1st Qu.:107.5   Yes : 58           Parity_2:79  
##  ID_003 :  1   Median :3.000   Median :144.0   NA's:  1           Parity_3:56  
##  ID_004 :  1   Mean   :2.774   Mean   :143.3                      Parity_4:45  
##  ID_005 :  1   3rd Qu.:4.000   3rd Qu.:176.5                      Parity_5:10  
##  ID_006 :  1   Max.   :6.000   Max.   :274.0                      Parity_6:13  
##  (Other):237                                                                   
##  parity_group   ID_simple    age_group   parity_fct_cut
##  First : 40   ID_1   :  1   Early : 54   First : 40    
##  Second: 79   ID_2   :  1   Middle:159   Second: 79    
##  Older :124   ID_3   :  1   Late  : 30   Older :124    
##               ID_4   :  1                              
##               ID_5   :  1                              
##               ID_6   :  1                              
##               (Other):237
\end{verbatim}

This parity\_fct\_cut variable is identical to the parity\_fct variable
that we created above.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{more-variable-types}{%
\subsubsection{More variable types}\label{more-variable-types}}

Although our fetuses data only has numeric and factor variable types, we
will sometimes encounter other types of data. The most common of these
are dates, date/times, ordinal, logical, and numbers with specialised
formats (e.g.~currency symbols).

\hypertarget{dates}{%
\paragraph{Dates}\label{dates}}

Dates are a very specific type of variable that we can do special things
with, such as calculating the number of days between two dates, and
extracting parts of the date e.g.~the year, day of the week, month name
etc. But in order to be able to do this, R must first store the variable
as a date. When reading an Excel file using read\_excel this is usually
done automatically, but sometimes we can end up with a text variable
that contains text representing the date. In this case, we can use the
parse\_date function if the date is written in the ISO standard format
of YYYY-MM-DD:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{parse_date}\NormalTok{(}\StringTok{'2010-10-21'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2010-10-21"
\end{verbatim}

If the date is written in a non-standard format (which is unfortunately
more common than the standard format!), then you will need to tell R
what format it is in. The lubridate package has some helpful functions
to do this, for example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{'lubridate'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 
## Attaching package: 'lubridate'
\end{verbatim}

\begin{verbatim}
## The following object is masked from 'package:base':
## 
##     date
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ymd}\NormalTok{(}\StringTok{'2010/10/21'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2010-10-21"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{make_date}\NormalTok{(}\DataTypeTok{year=}\DecValTok{2010}\NormalTok{, }\DataTypeTok{month=}\DecValTok{10}\NormalTok{, }\DataTypeTok{day=}\DecValTok{21}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2010-10-21"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{dmy}\NormalTok{(}\StringTok{'21-10-2010'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2010-10-21"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mdy}\NormalTok{(}\StringTok{'10-21-2010'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2010-10-21"
\end{verbatim}

A very common application of dates is to calculate a difference between
two dates. The best way to do this is to subtract one date from another,
and then use the as.numeric function to convert the time difference into
a simple number using the appropriate units. For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt1 <-}\StringTok{ }\KeywordTok{parse_date}\NormalTok{(}\StringTok{'2018-01-01'}\NormalTok{)}
\NormalTok{dt1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2018-01-01"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt2 <-}\StringTok{ }\KeywordTok{parse_date}\NormalTok{(}\StringTok{'2018-02-03'}\NormalTok{)}
\NormalTok{dt2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2018-02-03"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.numeric}\NormalTok{(dt2 }\OperatorTok{-}\StringTok{ }\NormalTok{dt1, }\DataTypeTok{units=}\StringTok{'days'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 33
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.numeric}\NormalTok{(dt2 }\OperatorTok{-}\StringTok{ }\NormalTok{dt1, }\DataTypeTok{units=}\StringTok{'weeks'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4.714286
\end{verbatim}

It is also possible to add or subtract a given number of days to a date
in a similar way:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt1 }\OperatorTok{+}\StringTok{ }\DecValTok{33}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2018-02-03"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt1 }\OperatorTok{-}\StringTok{ }\DecValTok{1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2017-12-31"
\end{verbatim}

\hypertarget{datetimes}{%
\paragraph{Date/times}\label{datetimes}}

Dates are relatively simple to work with, but date/times have the
additional complexity of time zones. Unless you specifically need the
time to be represented, you are much better off with simple dates.
Unfortunately, Excel will save dates as date/time objects so we end up
with these when we import them to R. For this reason, it is often a good
idea to convert these to a simple date using the as.Date function, for
example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dt <-}\StringTok{ }\KeywordTok{as.POSIXct}\NormalTok{(}\StringTok{'2010-02-15 05:00'}\NormalTok{)}
\NormalTok{dt}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2010-02-15 05:00:00 CET"
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.Date}\NormalTok{(dt)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "2010-02-15"
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{ordinal}{%
\paragraph{Ordinal}\label{ordinal}}

There is an important theoretical difference between ordinal data (where
there is an order to the categories observed, e.g.~body condition score)
and categorical data (where there is no logical order, e.g.~breed). This
distinction is less important in R, so we tend to use factors to
represent both. However, there is a specific type of factor that it is
occasionally useful to use, called an ordered factor. These are created
using the same parse\_factor and cut functions that we explored earlier,
but with the additional argument: ordered=TRUE. For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{parity_fct =} \KeywordTok{parse_factor}\NormalTok{(}\KeywordTok{str_c}\NormalTok{(}\StringTok{'Parity_'}\NormalTok{, parity), }
        \DataTypeTok{levels=}\KeywordTok{str_c}\NormalTok{(}\StringTok{'Parity_'}\NormalTok{, }\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from=}\DecValTok{1}\NormalTok{, }\DataTypeTok{to=}\DecValTok{10}\NormalTok{, }\DataTypeTok{by=}\DecValTok{1}\NormalTok{)))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{parity_ord =} \KeywordTok{parse_factor}\NormalTok{(}\KeywordTok{str_c}\NormalTok{(}\StringTok{'Parity_'}\NormalTok{, parity), }
        \DataTypeTok{levels=}\KeywordTok{str_c}\NormalTok{(}\StringTok{'Parity_'}\NormalTok{, }\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from=}\DecValTok{1}\NormalTok{, }\DataTypeTok{to=}\DecValTok{10}\NormalTok{, }\DataTypeTok{by=}\DecValTok{1}\NormalTok{)), }\DataTypeTok{ordered=}\OtherTok{TRUE}\NormalTok{))}

\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{str}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Classes 'tbl_df', 'tbl' and 'data.frame':    243 obs. of  10 variables:
##  $ ID                : Factor w/ 243 levels "ID_001","ID_002",..: 1 2 3 4 5 6 7 8 9 10 ...
##  $ parity            : num  3 2 1 1 2 3 2 2 6 4 ...
##  $ age_days          : num  274 196 259 249 221 221 177 82 193 142 ...
##  $ hair_coronary_band: Factor w/ 2 levels "No","Yes": 1 NA 2 2 2 2 2 1 2 1 ...
##  $ parity_fct        : Factor w/ 10 levels "Parity_1","Parity_2",..: 3 2 1 1 2 3 2 2 6 4 ...
##  $ parity_group      : Factor w/ 3 levels "First","Second",..: 3 2 1 1 2 3 2 2 3 3 ...
##  $ ID_simple         : Factor w/ 243 levels "ID_1","ID_2",..: 1 2 3 4 5 6 7 8 9 10 ...
##  $ age_group         : Factor w/ 3 levels "Early","Middle",..: 3 2 3 3 3 3 2 1 2 2 ...
##  $ parity_fct_cut    : Factor w/ 3 levels "First","Second",..: 3 2 1 1 2 3 2 2 3 3 ...
##  $ parity_ord        : Ord.factor w/ 10 levels "Parity_1"<"Parity_2"<..: 3 2 1 1 2 3 2 2 6 4 ...
\end{verbatim}

Using parity\_ord rather than parity\_fct will make a subtle difference
to the modelling functions, but will make no difference to plotting or
stratifying by the variable. Just temember that the order of the factor
levels is more important for ordered factors than it is for standard
(non-ordered) factors: this is why the levels are shown as
``Parity\_1''\textless{}``Parity\_2''\textless.. rather than
``Parity\_1'',``Parity\_2'',.. in the output of str().

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{logical}{%
\paragraph{Logical}\label{logical}}

We can represent binary data as logical (FALSE/TRUE), and R has a
special type called logical that can be used for this. It is possible to
use this type for e.g.~results of diagnostic tests, where there is a
logical FALSE/TRUE outcome. However, the same thing can also be
represented using a factor with two levels Negative/Positive, so for the
sake of consistency it is generally a good idea to just stick to using
factors. To convert a logical variable into a factor variable, you can
use the str\_c function as we did for integer numbers:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{testresult <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{NA}\NormalTok{)}
\NormalTok{testresult}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE  TRUE    NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str_c}\NormalTok{(testresult)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "FALSE" "TRUE"  NA
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{parse_factor}\NormalTok{(}\KeywordTok{str_c}\NormalTok{(testresult), }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'FALSE'}\NormalTok{,}\StringTok{'TRUE'}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE TRUE  <NA> 
## Levels: FALSE TRUE <NA>
\end{verbatim}

To re-label FALSE and TRUE to Negative and Positive (or similar) and/or
remove the NA (missing) factor level, use the fct\_collapse (or similar
fct\_relabel) function as we did before.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{numbers-with-special-formats}{%
\paragraph{Numbers with special
formats}\label{numbers-with-special-formats}}

Sometimes we will want to read numbers from text, if for example there
are non-numeric characters such as Â£ or â‚¬ in the text. We can use the
parse\_number function to do this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{price <-}\StringTok{ "â‚¬103,401"}
\KeywordTok{parse_number}\NormalTok{(price)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 103401
\end{verbatim}

Notice that R is english-centric by default, so a danish-formatted
number will be parsed incorrectly:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{danish_price <-}\StringTok{ "DKK 103.401,00"}
\KeywordTok{parse_number}\NormalTok{(danish_price)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 103.401
\end{verbatim}

We get DKK 103,40 rather than DKK 103.401 - but this can be overcome by
setting the locale:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{danish_price <-}\StringTok{ "DKK 103.401,00"}
\KeywordTok{parse_number}\NormalTok{(danish_price, }\DataTypeTok{locale=}\KeywordTok{locale}\NormalTok{(}\DataTypeTok{decimal_mark =} \StringTok{","}\NormalTok{, }\DataTypeTok{grouping_mark =} \StringTok{"."}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 103401
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{converting-multiple-columns}{%
\subsubsection{Converting multiple
columns}\label{converting-multiple-columns}}

Let's go back to the original dataset fetuses\_full:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses_full }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      parity         age_days        weight_kg           crl_cm      
##  Min.   :1.000   Min.   : 25.00   Min.   : 0.0010   Min.   :  2.00  
##  1st Qu.:2.000   1st Qu.: 95.25   1st Qu.: 0.2537   1st Qu.: 18.30  
##  Median :3.000   Median :136.00   Median : 1.7805   Median : 35.65  
##  Mean   :2.752   Mean   :136.06   Mean   : 5.0029   Mean   : 37.90  
##  3rd Qu.:4.000   3rd Qu.:175.00   3rd Qu.: 6.9250   3rd Qu.: 54.60  
##  Max.   :6.000   Max.   :274.00   Max.   :41.6000   Max.   :101.30  
##  head_width_mm    head_length_mm   hair_coronary_band   hair_ear        
##  Min.   :  3.00   Min.   :  5.00   Length:262         Length:262        
##  1st Qu.: 39.24   1st Qu.: 55.52   Class :character   Class :character  
##  Median : 63.33   Median :101.28   Mode  :character   Mode  :character  
##  Mean   : 62.34   Mean   :103.29                                        
##  3rd Qu.: 84.02   3rd Qu.:145.54                                        
##  Max.   :152.00   Max.   :239.00                                        
##  hair_eyelid         hair_tail         hair_hornbud       tactile_muzzle    
##  Length:262         Length:262         Length:262         Length:262        
##  Class :character   Class :character   Class :character   Class :character  
##  Mode  :character   Mode  :character   Mode  :character   Mode  :character  
##                                                                             
##                                                                             
##                                                                             
##  tactile_eyebrow    tactile_eyelash    eye_op_close       papillae_tongue   
##  Length:262         Length:262         Length:262         Length:262        
##  Class :character   Class :character   Class :character   Class :character  
##  Mode  :character   Mode  :character   Mode  :character   Mode  :character  
##                                                                             
##                                                                             
##                                                                             
##     eyelid              sex                crl_mm      
##  Length:262         Length:262         Min.   :  20.0  
##  Class :character   Class :character   1st Qu.: 183.0  
##  Mode  :character   Mode  :character   Median : 356.5  
##                                        Mean   : 379.0  
##                                        3rd Qu.: 546.0  
##                                        Max.   :1013.0
\end{verbatim}

We now know how to format each of these variables as either a factor or
number one by one - for example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses_full }\OperatorTok{%>%}\StringTok{ }
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_coronary_band =} \KeywordTok{parse_factor}\NormalTok{(hair_coronary_band, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{,}\StringTok{'Y'}\NormalTok{))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_ear =} \KeywordTok{parse_factor}\NormalTok{(hair_ear, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{,}\StringTok{'Y'}\NormalTok{))) }\OperatorTok{%>%}\StringTok{ }
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_eyelid =} \KeywordTok{parse_factor}\NormalTok{(hair_eyelid, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{,}\StringTok{'Y'}\NormalTok{))) }\OperatorTok{%>%}\StringTok{ }
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_tail =} \KeywordTok{parse_factor}\NormalTok{(hair_tail, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{,}\StringTok{'Y'}\NormalTok{))) }\OperatorTok{%>%}\StringTok{ }
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_hornbud =} \KeywordTok{parse_factor}\NormalTok{(hair_hornbud, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{,}\StringTok{'Y'}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

And so on. The best approach is to copy and paste the code and just
change the name of the variable each time - it is a bit tedious but not
difficult. With a bit of practice, you will be surprised how quickly you
can get this done.

A good tip is to quickly change all character (text) variables into
factors and then immediately use summary on the result: this allows us
to see what different values the data contains for each of the text
variables. We can do this using mutate\_if and the condition
is\_character:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}\StringTok{ }
\StringTok{    }\KeywordTok{mutate_if}\NormalTok{(is_character, parse_factor) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      parity         age_days        weight_kg           crl_cm      
##  Min.   :1.000   Min.   : 25.00   Min.   : 0.0010   Min.   :  2.00  
##  1st Qu.:2.000   1st Qu.: 95.25   1st Qu.: 0.2537   1st Qu.: 18.30  
##  Median :3.000   Median :136.00   Median : 1.7805   Median : 35.65  
##  Mean   :2.752   Mean   :136.06   Mean   : 5.0029   Mean   : 37.90  
##  3rd Qu.:4.000   3rd Qu.:175.00   3rd Qu.: 6.9250   3rd Qu.: 54.60  
##  Max.   :6.000   Max.   :274.00   Max.   :41.6000   Max.   :101.30  
##  head_width_mm    head_length_mm   hair_coronary_band hair_ear hair_eyelid
##  Min.   :  3.00   Min.   :  5.00   N:202              N:221    N:197      
##  1st Qu.: 39.24   1st Qu.: 55.52   Y: 60              Y: 41    Y: 65      
##  Median : 63.33   Median :101.28                                          
##  Mean   : 62.34   Mean   :103.29                                          
##  3rd Qu.: 84.02   3rd Qu.:145.54                                          
##  Max.   :152.00   Max.   :239.00                                          
##  hair_tail hair_hornbud     tactile_muzzle    tactile_eyebrow
##  N:179     N:175        Visible    :169    Visible    :169   
##  Y: 83     Y: 87        Not visible: 34    Not visible: 43   
##                         Hairsack   : 59    Hairsack   : 50   
##                                                              
##                                                              
##                                                              
##     tactile_eyelash eye_op_close      papillae_tongue eyelid        sex     
##  Visible    :109    Open  : 37   Whole tongue :164    Y:241   Female  :110  
##  Not visible:130    Closed:225   None         : 35    N: 21   Male    :128  
##  Hairsack   : 23                 Large front  : 35            Non Diff: 24  
##                                  Furthest back: 28                          
##                                                                             
##                                                                             
##      crl_mm      
##  Min.   :  20.0  
##  1st Qu.: 183.0  
##  Median : 356.5  
##  Mean   : 379.0  
##  3rd Qu.: 546.0  
##  Max.   :1013.0
\end{verbatim}

We don't specify the levels manually, but that's OK because all we
wanted to do is quickly see what is in there - we are not saving the
result (or any potential issues generated by data entry mistakes).

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{section-3-basic-data-visualisation}{%
\subsection{Section 3: basic data
visualisation}\label{section-3-basic-data-visualisation}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{basic-plots}{%
\subsubsection{Basic plots}\label{basic-plots}}

We can get a lot of information using the summarise() variable, but
sometimes it is better to visualise data graphically to check that the
observations are consistent with what we expect. There are several ways
to make plots in R, but the tidyverse way is to use ggplot. These plots
all start with the same pattern - first we define the data frame we want
to use, then we specify which variables should go on the x and y axes
(as well as any variables that can be used to group by colour etc) using
the aes() function, then we add the `layers' that we want to the plot.
For example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(fetuses_full, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\NormalTok{head_width_mm, }\DataTypeTok{y=}\NormalTok{head_length_mm)) }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidyverse_fetuses_files/figure-latex/unnamed-chunk-61-1.pdf}

The first line says that we want to use the fetuses\_full dataset, and
that we want head\_width\_mm on the x-axis and head\_length\_mm on the
y-axis. The first line doesn't tell R what type of plot we want, but it
ends with a + symbol, which is a lot like the \%\textgreater\% operator
in that it tells R that we have not completed the command. The second
line tells R that we want to add points to the plot, so we end up with a
simple scatter-type plot. We can also add a smoothed line of best fit as
a second layer using:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(fetuses_full, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\NormalTok{head_width_mm, }\DataTypeTok{y=}\NormalTok{head_length_mm)) }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}
\StringTok{    }\KeywordTok{stat_smooth}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## `geom_smooth()` using method = 'loess' and formula 'y ~ x'
\end{verbatim}

\includegraphics{tidyverse_fetuses_files/figure-latex/unnamed-chunk-62-1.pdf}

These graphs look OK electronically but the grey background is not ideal
for printing (or for use in publication). To change the default theme to
a simpler black and white colour scheme use the following:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{theme_set}\NormalTok{(}\KeywordTok{theme_bw}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

All future plots within this R session will now use this colour scheme.
Note that you can also save plots to file, for example as PDF or TIFF
format, using the ggsave function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(fetuses_full, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\NormalTok{head_width_mm, }\DataTypeTok{y=}\NormalTok{head_length_mm)) }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}
\StringTok{    }\KeywordTok{stat_smooth}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidyverse_fetuses_files/figure-latex/unnamed-chunk-64-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggsave}\NormalTok{(}\StringTok{'headlengthvswidth.pdf'}\NormalTok{)}
\KeywordTok{ggsave}\NormalTok{(}\StringTok{'headlengthvswidth.tiff'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To see additional options for e.g.~the height and width of these plots,
see the help file for ggsave by typing:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?ggsave}
\end{Highlighting}
\end{Shaded}

\hypertarget{summary-plots}{%
\subsubsection{Summary plots}\label{summary-plots}}

There are two types of plots that are particularly useful for
summarising data: histograms and box plots. We can create these using
similar code to the basic plot above:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(fetuses_full, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\NormalTok{head_width_mm)) }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom_histogram}\NormalTok{(}\DataTypeTok{binwidth=}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidyverse_fetuses_files/figure-latex/unnamed-chunk-66-1.pdf}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(fetuses_full, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{y=}\NormalTok{head_width_mm, }\DataTypeTok{x=}\NormalTok{hair_coronary_band)) }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom_boxplot}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidyverse_fetuses_files/figure-latex/unnamed-chunk-66-2.pdf}

Notice that the histogram does not need us to specify anything for the
y-axis: the frequencies are automatically calculated for us. These two
plots tell us that head\_width\_mm is approximately normally
distributed, and that it is strongly associated with the presence of
hair on the coronary band. There do not seem to be any extreme values,
so there is no evidence of data entry mistakes for this variable based
on these plots.

We might also want to make a bar plot to check how categorical variables
relate to each other. For example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(fetuses_full, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\NormalTok{hair_coronary_band)) }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom_bar}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidyverse_fetuses_files/figure-latex/unnamed-chunk-67-1.pdf}

This tells us that most of the fetuses do not have hair on the corony
band. If we wanted to see how this related to another categorical
variable, then we can create a stacked bar chart by using the fill
argument to aes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(fetuses_full, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\NormalTok{hair_coronary_band, }\DataTypeTok{fill=}\NormalTok{hair_tail)) }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom_bar}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidyverse_fetuses_files/figure-latex/unnamed-chunk-68-1.pdf}

We will do more with plots later in the course, but if you want to read
more about ggplot now then see the Data visualisation chapter of the R
for Data Science book
(\url{https://r4ds.had.co.nz/data-visualisation.html}). There is also a
cookbook for common plot recipes using ggplot at:
\url{http://www.cookbook-r.com/Graphs/}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{long-and-wide-data}{%
\subsubsection{Long and wide data}\label{long-and-wide-data}}

Sometimes we encounter datasets that are structured in a way that might
be good for data entry, but is bad for data analysis. For example, we
might have repeated observations of the same variable over time within
the same individual represented as multiple columns within the
worksheet: this `wide format' is a common way to enter the data, but
makes it difficult to summarise all the observations from the same
individual using R. For example we might have the following dataset
(that I will create directly in R using the tribble() function just for
illustration):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{wide <-}\StringTok{ }\KeywordTok{tribble}\NormalTok{(}
        \OperatorTok{~}\NormalTok{ID, }\OperatorTok{~}\NormalTok{Time1, }\OperatorTok{~}\NormalTok{Time2, }\OperatorTok{~}\NormalTok{Time3,}
        \StringTok{'Ben'}\NormalTok{, }\DecValTok{78}\NormalTok{, }\DecValTok{75}\NormalTok{, }\DecValTok{73}\NormalTok{,}
        \StringTok{'Geoff'}\NormalTok{, }\DecValTok{91}\NormalTok{, }\DecValTok{87}\NormalTok{, }\DecValTok{89}
\NormalTok{    )}
\NormalTok{wide}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 2 x 4
##   ID    Time1 Time2 Time3
##   <chr> <dbl> <dbl> <dbl>
## 1 Ben      78    75    73
## 2 Geoff    91    87    89
\end{verbatim}

Here we have 3 repeated observations of the same variable (body weight),
at 3 different time points for 2 individuals. Now let's say we want to
plot these weights over time - how do we do that? For data analysis we
really want the data in `long format', where we have a column for the ID
of the individual, a column for the time point, and a single column for
all of the observations. So to create the plot, we first convert the
data to long format using the gather() function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{long <-}\StringTok{ }\NormalTok{wide }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{gather}\NormalTok{(TimePoint, Weight, }\OperatorTok{-}\NormalTok{ID) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{TimePoint =} \KeywordTok{parse_factor}\NormalTok{(TimePoint)) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{ID =} \KeywordTok{parse_factor}\NormalTok{(ID, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'Ben'}\NormalTok{,}\StringTok{'Geoff'}\NormalTok{)))}
\NormalTok{long}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## # A tibble: 6 x 3
##   ID    TimePoint Weight
##   <fct> <fct>      <dbl>
## 1 Ben   Time1         78
## 2 Geoff Time1         91
## 3 Ben   Time2         75
## 4 Geoff Time2         87
## 5 Ben   Time3         73
## 6 Geoff Time3         89
\end{verbatim}

The first 2 arguments of the gather function allows us to specify the
new column name for the grouping variable, and the new column name for
the observation variable. The grouping variable values are determined by
the corresponding previous column names (in this case Time1, Time2 and
Time3), and the observation variable values (the observed weights) are
the observed data gathered from all of the previous columns. The
remaining arguments indicate variables (with a minus in front of the
name) that we want to exclude from the gather process: these variables
(in our case just one variable: ID) will be added to the resulting long
data in the same format, but with rows repeated as necessary. We then
use the parse\_factor function to convert the new text variable
TimePoint into a factor (along with ID). Notice that we do not bother to
specify the levels for the new TimePoint variable: this is because the
variable is taken directly from the old column names, so there is no
risk of any data entry mistakes! The result is exactly the same data,
but represented differently: the wide data has the 6 observations in 3
columns of 2 rows, and the long data has the same observations in a
single variable with 6 rows. Now we can make the plot we wanted:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(long, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\NormalTok{TimePoint, }\DataTypeTok{y=}\NormalTok{Weight, }\DataTypeTok{col=}\NormalTok{ID, }\DataTypeTok{group=}\NormalTok{ID)) }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom_line}\NormalTok{() }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidyverse_fetuses_files/figure-latex/unnamed-chunk-71-1.pdf}

The argument col=ID has been added to the aes() function so we can see
which observations belong to which person, and also a new layer
geom\_line() which connects the observations within the group specified
as group=ID within the aes() function.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

The gather function also comes in handy for making similar types of
plots where we want to put different variables side-by-side. For
example, we might want to look at how the head\_width\_mm,
head\_length\_mm and crl\_cm variables change with age\_days. We can do
that one at a time using the existing data frame, for example:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(fetuses_full, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\NormalTok{age_days, }\DataTypeTok{y=}\NormalTok{head_width_mm)) }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidyverse_fetuses_files/figure-latex/unnamed-chunk-72-1.pdf}

But how do we add head\_length\_mm and crl\_cm to this plot? We need to
convert the data into long format, and then make the plot:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plotdata <-}\StringTok{ }\NormalTok{fetuses_full }\OperatorTok{%>%}\StringTok{ }
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{ID =} \KeywordTok{row_number}\NormalTok{()) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{select}\NormalTok{(ID, age_days, crl_cm, head_width_mm, head_length_mm) }\OperatorTok{%>%}\StringTok{ }
\StringTok{    }\KeywordTok{gather}\NormalTok{(Measurement, Length, }\OperatorTok{-}\NormalTok{ID, }\OperatorTok{-}\NormalTok{age_days) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{Measurement =} \KeywordTok{parse_factor}\NormalTok{(Measurement))}

\KeywordTok{str}\NormalTok{(plotdata)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Classes 'tbl_df', 'tbl' and 'data.frame':    786 obs. of  4 variables:
##  $ ID         : int  1 2 3 4 5 6 7 8 9 10 ...
##  $ age_days   : num  274 196 259 249 221 221 177 82 193 142 ...
##  $ Measurement: Factor w/ 3 levels "crl_cm","head_width_mm",..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ Length     : num  86.8 61.8 89.3 83 75.4 77.7 55.4 10.4 62.4 35.4 ...
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(plotdata, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\NormalTok{age_days, }\DataTypeTok{y=}\NormalTok{Length, }\DataTypeTok{col=}\NormalTok{Measurement)) }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidyverse_fetuses_files/figure-latex/unnamed-chunk-73-1.pdf}

This code has several steps: first we add an ID variable so that we know
how the rows in the new data frame relate to the rows in the
fetuses\_full data frame, then we extract the variables we are
interested in using select(), then we use gather to convert all columns
in the data into long format (with the exception of ID and age\_days),
then we make the plot. You can see from the structure of plotdata that
we now have 786 observations, which is exactly three times the original
262 observations because each ID is repeated three times. This process
of creating a new data frame containing the specific data that we want
to plot (and in the correct format) is something we will do a lot.

What happens if we want to add weight to the plot? All we have to do is
copy and paste the code above, and add weight\_kg in the relevant place:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{plotdata <-}\StringTok{ }\NormalTok{fetuses_full }\OperatorTok{%>%}\StringTok{ }
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{ID =} \KeywordTok{row_number}\NormalTok{()) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{select}\NormalTok{(ID, age_days, crl_cm, head_width_mm, head_length_mm, weight_kg) }\OperatorTok{%>%}\StringTok{ }
\StringTok{    }\KeywordTok{gather}\NormalTok{(Measurement, Length, }\OperatorTok{-}\NormalTok{ID, }\OperatorTok{-}\NormalTok{age_days) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{Measurement =} \KeywordTok{parse_factor}\NormalTok{(Measurement)) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{Measurement =} 
       \KeywordTok{fct_collapse}\NormalTok{(Measurement, }\StringTok{"CRL (cm)"}\NormalTok{=}\StringTok{"crl_cm"}\NormalTok{, }
         \StringTok{"Head Width (mm)"}\NormalTok{=}\StringTok{"head_width_mm"}\NormalTok{, }\StringTok{"Head Length (mm)"}\NormalTok{=}\StringTok{"head_length_mm"}\NormalTok{,}
         \StringTok{"Weight (kg)"}\NormalTok{=}\StringTok{"weight_kg"}\NormalTok{))}

\KeywordTok{ggplot}\NormalTok{(plotdata, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\NormalTok{age_days, }\DataTypeTok{y=}\NormalTok{Length, }\DataTypeTok{col=}\NormalTok{Measurement)) }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}
\StringTok{    }\KeywordTok{xlab}\NormalTok{(}\StringTok{'Age (days)'}\NormalTok{) }\OperatorTok{+}
\StringTok{    }\KeywordTok{ylab}\NormalTok{(}\StringTok{''}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{tidyverse_fetuses_files/figure-latex/unnamed-chunk-74-1.pdf}

The only addition is that the x-axis label and names of the factor
levels have been changed to a more readable format, and the y-axis label
has been removed as weight isn't a length! But the weight is on a
different scale to the other variables so is hard to see at the bottom
of the graph. There are two ways to improve this: we could change the
units of weight so that 1 y-axis value represented 100g rather than 1kg,
but it is probably a better idea to put the different variables into
different facets using the facet\_wrap() function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(plotdata, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x=}\NormalTok{age_days, }\DataTypeTok{y=}\NormalTok{Length)) }\OperatorTok{+}
\StringTok{    }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}
\StringTok{    }\KeywordTok{xlab}\NormalTok{(}\StringTok{'Age (days)'}\NormalTok{) }\OperatorTok{+}
\StringTok{    }\KeywordTok{ylab}\NormalTok{(}\StringTok{''}\NormalTok{) }\OperatorTok{+}
\StringTok{    }\KeywordTok{facet_wrap}\NormalTok{(}\OperatorTok{~}\NormalTok{Measurement, }\DataTypeTok{scales=}\StringTok{'free_y'}\NormalTok{) }
\end{Highlighting}
\end{Shaded}

\includegraphics{tidyverse_fetuses_files/figure-latex/unnamed-chunk-75-1.pdf}

The facet\_wrap (and related facet\_grid) funtion allow us to specify
one or more categorical variable on which we can stratify the plot into
different sub-plots. The scales=`free\_y' argument tells facet\_wrap to
use different y-axis scales for each variable type.

If you want to read more about tidy data structure (including long vs
wide formats) then see the Tidy data chapter of the R for Data Science
book (\url{https://r4ds.had.co.nz/tidy-data.html}).

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{appendix-a-additional-tips}{%
\subsection{Appendix A: additional
tips}\label{appendix-a-additional-tips}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\begin{itemize}
\item
  Never write code from scratch when you can copy and paste working code
  from an example you already have. The process for importing and
  formatting data is nearly always the same, and as a result the code
  will be largely identical with just a few changes to variable names.
  If you write code from scratch then (1) it will be slower because you
  will have to remember how to write everything, and (2) it will be more
  frustrating because you will make more mistakes. It is a good idea to
  keep a specific R script file handy with examples of how to do
  different things - you can use this document as a starting point.
\item
  If you need to do something that you haven't done before, then try
  looking at the cheat sheets for either data import
  (\url{https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf}),
  data wrangling
  (\url{https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf}),
  data visualisation
  (\url{https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf}),
  or one of the other cheat sheets available via the RStudio website
  (\url{https://www.rstudio.com/resources/cheatsheets/}). If you still
  can't find what you are looking for then you can try googling what you
  want to do, but be aware that you might get lots of different
  solutions for the same problem, and some of them will look extremely
  complex and/or unfamiliar. If you include the word `tidyverse' in your
  search then you are more likely to find a familiar-looking solution.
\item
  R script files are really just text files, so it is a good idea to
  stick to standard ASCII text characters - these do not include Ã¦, Ã¸ or
  Ã¥. You can use these in comments with only one small drawback: you
  will then get asked for an encoding to use when saving the file (pick
  either latin1 or UTF-8). It is important to \textbf{ALWAYS} write lots
  of useful comments in your R scripts, so if you prefer to stick to
  danish for your comments then feel free. But you should definitely not
  use Ã¥ Ã¦ or Ã¸ in the R code itself, including in variable names: this
  can lead to problems with your code spontaneously breaking if the
  encoding is changed later on (this can happen just by sending the R
  script file over email). You can always use ae, oe and aa instead of
  Ã¦, Ã¸ and Ã¥.
\item
  When you are writing R scripts, try to make sure that the entire
  script file contains valid code all the way though, and that the code
  at the start of the R script does not depend on code written further
  down in the script. You should be able to clean out your environment
  by clicking the sweeping brush button to the right of `Import
  Dataset', and then re-create all of your work just by clicking on
  `source'. This ability to re-create an entire analysis from scratch at
  the click of a button (if for example your data changes) is a major
  advantage of using R. This also means that if you re-open RStudio you
  are guaranteed to be able to get back to where you were just before
  you closed it (or it crashed, which can happen) - so it is a good idea
  to test this periodically to make sure that you don't get any errors.
  You will also need to do this if you make a mistake and either delete
  something that you didn't mean to, or break a variable by e.g.~using
  mutate to convert it to a factor but mis-typing or forgetting about
  one of the levels.
\item
  As a general rule, R ignores white space (including spaces and line
  breaks), so it doesn't really matter in terms of the code if we use
  them or not. But it is MUCH easier for humans to read and understand
  your code if it is laid out in a consistent and clear way. So get into
  the habit of putting spaces between functions and arguments, and
  breaking large chains of functions over separate lines (typically
  after a , or + or \%\textgreater\%). You might still end up with some
  long lines, and by default you need to scroll to see these if they
  disappear off the right hand side of the screen. If that annoys you,
  then go to the Tools menu, then Global Options, then click on the Code
  tab and make sure that `Soft-wrap R source files' is checked - this
  makes sure that the width of the R script file matches the width of
  the text window by `soft-wrapping' the text.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{appendix-b-exercise}{%
\subsection{Appendix B: exercise}\label{appendix-b-exercise}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

Take the R code given in this tutorial and use it to create a complete R
script to read and format all of the variables in the data frame. You
should end up with a data frame called `fetuses' that looks exactly like
this:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{str}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Classes 'tbl_df', 'tbl' and 'data.frame':    262 obs. of  22 variables:
##  $ ID                : Factor w/ 262 levels "ID_001","ID_002",..: 1 2 3 4 5 6 7 8 9 10 ...
##  $ sex               : Factor w/ 3 levels "Female","Male",..: 1 1 2 2 1 1 2 2 2 1 ...
##  $ parity            : Factor w/ 6 levels "Parity_1","Parity_2",..: 3 2 1 1 2 3 2 2 6 4 ...
##  $ parity_group      : Factor w/ 3 levels "First","Second",..: 3 2 1 1 2 3 2 2 3 3 ...
##  $ age_days          : num  274 196 259 249 221 221 177 82 193 142 ...
##  $ age_group         : Factor w/ 3 levels "Early","Middle",..: 3 2 3 3 3 3 2 1 2 2 ...
##  $ weight_kg         : num  35.5 10.2 27.1 29.1 16.6 ...
##  $ crl_cm            : num  86.8 61.8 89.3 83 75.4 77.7 55.4 10.4 62.4 35.4 ...
##  $ crl_mm            : num  868 618 893 830 754 777 554 104 624 354 ...
##  $ head_width_mm     : num  128 83.8 121 118 100.6 ...
##  $ head_length_mm    : num  239 154 220 215 183 ...
##  $ hair_coronary_band: Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 2 1 2 1 ...
##  $ hair_ear          : Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 1 1 1 1 ...
##  $ hair_eyelid       : Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 2 1 2 1 ...
##  $ hair_tail         : Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 2 1 2 1 ...
##  $ hair_hornbud      : Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 2 1 2 1 ...
##  $ tactile_muzzle    : Factor w/ 3 levels "Visible","Not visible",..: 1 1 1 1 1 1 1 2 1 1 ...
##  $ tactile_eyebrow   : Factor w/ 3 levels "Visible","Not visible",..: 1 1 1 1 1 1 1 2 1 1 ...
##  $ tactile_eyelash   : Factor w/ 3 levels "Visible","Not visible",..: 1 1 1 1 1 1 1 2 1 2 ...
##  $ eye_op_close      : Factor w/ 2 levels "Closed","Open": 2 2 2 2 2 2 1 1 1 1 ...
##  $ papillae_tongue   : Factor w/ 4 levels "None","Furthest back",..: 4 4 4 4 4 4 4 1 4 4 ...
##  $ eyelid            : Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 2 2 2 2 ...
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        ID            sex           parity   parity_group    age_days     
##  ID_001 :  1   Female  :110   Parity_1:47   First : 47   Min.   : 25.00  
##  ID_002 :  1   Male    :128   Parity_2:83   Second: 83   1st Qu.: 95.25  
##  ID_003 :  1   Non Diff: 24   Parity_3:60   Older :132   Median :136.00  
##  ID_004 :  1                  Parity_4:47                Mean   :136.06  
##  ID_005 :  1                  Parity_5:10                3rd Qu.:175.00  
##  ID_006 :  1                  Parity_6:15                Max.   :274.00  
##  (Other):256                                                             
##   age_group     weight_kg           crl_cm           crl_mm      
##  Early : 73   Min.   : 0.0010   Min.   :  2.00   Min.   :  20.0  
##  Middle:159   1st Qu.: 0.2537   1st Qu.: 18.30   1st Qu.: 183.0  
##  Late  : 30   Median : 1.7805   Median : 35.65   Median : 356.5  
##               Mean   : 5.0029   Mean   : 37.90   Mean   : 379.0  
##               3rd Qu.: 6.9250   3rd Qu.: 54.60   3rd Qu.: 546.0  
##               Max.   :41.6000   Max.   :101.30   Max.   :1013.0  
##                                                                  
##  head_width_mm    head_length_mm   hair_coronary_band hair_ear  hair_eyelid
##  Min.   :  3.00   Min.   :  5.00   No :202            No :221   No :197    
##  1st Qu.: 39.24   1st Qu.: 55.52   Yes: 60            Yes: 41   Yes: 65    
##  Median : 63.33   Median :101.28                                           
##  Mean   : 62.34   Mean   :103.29                                           
##  3rd Qu.: 84.02   3rd Qu.:145.54                                           
##  Max.   :152.00   Max.   :239.00                                           
##                                                                            
##  hair_tail hair_hornbud     tactile_muzzle    tactile_eyebrow
##  No :179   No :175      Visible    :169    Visible    :169   
##  Yes: 83   Yes: 87      Not visible: 34    Not visible: 43   
##                         Hairsack   : 59    Hairsack   : 50   
##                                                              
##                                                              
##                                                              
##                                                              
##     tactile_eyelash eye_op_close      papillae_tongue eyelid   
##  Visible    :109    Closed:225   None         : 35    No : 21  
##  Not visible:130    Open  : 37   Furthest back: 28    Yes:241  
##  Hairsack   : 23                 Large front  : 35             
##                                  Whole tongue :164             
##                                                                
##                                                                
## 
\end{verbatim}

A complete solution is given in appendix D - look at this if you get
stuck.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{appendix-c-r-markdown-environment}{%
\subsection{Appendix C: R Markdown
environment}\label{appendix-c-r-markdown-environment}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

You can ignore this section - it is just for reference so that we can
see the exact version of R and the tidyverse package that was used to
automatically create the results shown here.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sessionInfo}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## R version 3.6.2 (2019-12-12)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS High Sierra 10.13.6
## 
## Matrix products: default
## BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] lubridate_1.7.4 readxl_1.3.1    forcats_0.4.0   stringr_1.4.0  
##  [5] dplyr_0.8.3     purrr_0.3.3     readr_1.3.1     tidyr_1.0.2    
##  [9] tibble_2.1.3    ggplot2_3.2.1   tidyverse_1.3.0
## 
## loaded via a namespace (and not attached):
##  [1] tidyselect_1.0.0 xfun_0.12        haven_2.2.0      lattice_0.20-38 
##  [5] colorspace_1.4-1 vctrs_0.2.2      generics_0.0.2   htmltools_0.4.0 
##  [9] yaml_2.2.0       utf8_1.1.4       rlang_0.4.4      pillar_1.4.3    
## [13] withr_2.1.2      glue_1.3.1       DBI_1.1.0        dbplyr_1.4.2    
## [17] modelr_0.1.5     lifecycle_0.1.0  munsell_0.5.0    gtable_0.3.0    
## [21] cellranger_1.1.0 rvest_0.3.5      evaluate_0.14    labeling_0.3    
## [25] knitr_1.27       fansi_0.4.1      broom_0.5.4      Rcpp_1.0.3      
## [29] scales_1.1.0     backports_1.1.5  jsonlite_1.6     farver_2.0.3    
## [33] fs_1.3.1         hms_0.5.3        digest_0.6.23    stringi_1.4.5   
## [37] grid_3.6.2       cli_2.0.1        tools_3.6.2      magrittr_1.5    
## [41] lazyeval_0.2.2   crayon_1.3.4     pkgconfig_2.0.3  ellipsis_0.3.0  
## [45] xml2_1.2.2       reprex_0.3.0     assertthat_0.2.1 rmarkdown_2.1   
## [49] httr_1.4.1       rstudioapi_0.10  R6_2.4.1         nlme_3.1-143    
## [53] compiler_3.6.2
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{appendix-d-exercise-solution}{%
\subsection{Appendix D: exercise
solution}\label{appendix-d-exercise-solution}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

To create the complete data handling code, we need to follow the 8 steps
given in the tutorial:

\hypertarget{step-1-load-the-required-packages}{%
\subparagraph{Step 1: load the required
packages}\label{step-1-load-the-required-packages}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(}\StringTok{'tidyverse'}\NormalTok{)}
\KeywordTok{library}\NormalTok{(}\StringTok{'readxl'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{step-2-remember-to-set-your-working-directory}{%
\subparagraph{Step 2: remember to set your working
directory}\label{step-2-remember-to-set-your-working-directory}}

Go to the Session menu, then Set Working Directory, then Choose
Directory.Â¨

\hypertarget{step-3-read-the-data-frame-into-r}{%
\subparagraph{Step 3: read the data frame into
R}\label{step-3-read-the-data-frame-into-r}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\KeywordTok{read_excel}\NormalTok{(}\StringTok{'calf_fetuses.xlsx'}\NormalTok{, }\DataTypeTok{sheet=}\StringTok{'calf_fetuses'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{step-4-examine-your-data}{%
\subparagraph{Step 4: examine your
data}\label{step-4-examine-your-data}}

Look at the structure to identify what needs to be formatted:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{str}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Classes 'tbl_df', 'tbl' and 'data.frame':    262 obs. of  18 variables:
##  $ parity            : num  3 2 1 1 2 3 2 2 6 4 ...
##  $ age_days          : num  274 196 259 249 221 221 177 82 193 142 ...
##  $ weight_kg         : num  35.5 10.2 27.1 29.1 16.6 ...
##  $ crl_cm            : num  86.8 61.8 89.3 83 75.4 77.7 55.4 10.4 62.4 35.4 ...
##  $ head_width_mm     : num  128 83.8 121 118 100.6 ...
##  $ head_length_mm    : num  239 154 220 215 183 ...
##  $ hair_coronary_band: chr  "Y" "Y" "Y" "Y" ...
##  $ hair_ear          : chr  "Y" "Y" "Y" "Y" ...
##  $ hair_eyelid       : chr  "Y" "Y" "Y" "Y" ...
##  $ hair_tail         : chr  "Y" "Y" "Y" "Y" ...
##  $ hair_hornbud      : chr  "Y" "Y" "Y" "Y" ...
##  $ tactile_muzzle    : chr  "Visible" "Visible" "Visible" "Visible" ...
##  $ tactile_eyebrow   : chr  "Visible" "Visible" "Visible" "Visible" ...
##  $ tactile_eyelash   : chr  "Visible" "Visible" "Visible" "Visible" ...
##  $ eye_op_close      : chr  "Open" "Open" "Open" "Open" ...
##  $ papillae_tongue   : chr  "Whole tongue" "Whole tongue" "Whole tongue" "Whole tongue" ...
##  $ eyelid            : chr  "Y" "Y" "Y" "Y" ...
##  $ sex               : chr  "Female" "Female" "Male" "Male" ...
\end{verbatim}

Other than age\_days, weight\_kg, crl\_cm, and head\_width/length\_mm we
will want to turn everything into a factor. We also want to create a new
ID variable and may also want to create some factor groups based on the
numeric variables.

We can also automatically convert the character variables to factors and
summarise, just to see what we have in the data:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate_if}\NormalTok{(is.character, parse_factor) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      parity         age_days        weight_kg           crl_cm      
##  Min.   :1.000   Min.   : 25.00   Min.   : 0.0010   Min.   :  2.00  
##  1st Qu.:2.000   1st Qu.: 95.25   1st Qu.: 0.2537   1st Qu.: 18.30  
##  Median :3.000   Median :136.00   Median : 1.7805   Median : 35.65  
##  Mean   :2.752   Mean   :136.06   Mean   : 5.0029   Mean   : 37.90  
##  3rd Qu.:4.000   3rd Qu.:175.00   3rd Qu.: 6.9250   3rd Qu.: 54.60  
##  Max.   :6.000   Max.   :274.00   Max.   :41.6000   Max.   :101.30  
##  head_width_mm    head_length_mm   hair_coronary_band hair_ear hair_eyelid
##  Min.   :  3.00   Min.   :  5.00   Y: 60              Y: 41    Y: 65      
##  1st Qu.: 39.24   1st Qu.: 55.52   N:202              N:221    N:197      
##  Median : 63.33   Median :101.28                                          
##  Mean   : 62.34   Mean   :103.29                                          
##  3rd Qu.: 84.02   3rd Qu.:145.54                                          
##  Max.   :152.00   Max.   :239.00                                          
##  hair_tail hair_hornbud     tactile_muzzle    tactile_eyebrow
##  Y: 83     Y: 87        Visible    :169    Visible    :169   
##  N:179     N:175        Not visible: 34    Not visible: 43   
##                         Hairsack   : 59    Hairsack   : 50   
##                                                              
##                                                              
##                                                              
##     tactile_eyelash eye_op_close      papillae_tongue eyelid        sex     
##  Visible    :109    Open  : 37   Whole tongue :164    Y:241   Female  :110  
##  Not visible:130    Closed:225   None         : 35    N: 21   Male    :128  
##  Hairsack   : 23                 Large front  : 35            Non Diff: 24  
##                                  Furthest back: 28                          
##                                                                             
## 
\end{verbatim}

\hypertarget{step-5-modify-your-data-frame}{%
\subparagraph{Step 5: modify your data
frame}\label{step-5-modify-your-data-frame}}

Create a new ID variable and turn it into a factor:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{ID =} \KeywordTok{row_number}\NormalTok{()) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{ID =} \KeywordTok{parse_factor}\NormalTok{(}\KeywordTok{str_c}\NormalTok{(}\StringTok{'ID_'}\NormalTok{, }\KeywordTok{str_replace_all}\NormalTok{(}\KeywordTok{format}\NormalTok{(ID),}\StringTok{' '}\NormalTok{,}\StringTok{'0'}\NormalTok{))))}
\end{Highlighting}
\end{Shaded}

Turn parity into a factor and create a grouped version:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{parity =} \KeywordTok{parse_factor}\NormalTok{(}\KeywordTok{str_c}\NormalTok{(}\StringTok{'Parity_'}\NormalTok{, parity), }
        \DataTypeTok{levels=}\KeywordTok{str_c}\NormalTok{(}\StringTok{'Parity_'}\NormalTok{, }\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from=}\DecValTok{1}\NormalTok{, }\DataTypeTok{to=}\DecValTok{10}\NormalTok{, }\DataTypeTok{by=}\DecValTok{1}\NormalTok{)))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{parity_group =} \KeywordTok{fct_collapse}\NormalTok{(parity, }\DataTypeTok{First=}\StringTok{'Parity_1'}\NormalTok{, }\DataTypeTok{Second=}\StringTok{'Parity_2'}\NormalTok{, }
        \DataTypeTok{Older=}\KeywordTok{str_c}\NormalTok{(}\StringTok{'Parity_'}\NormalTok{, }\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from=}\DecValTok{3}\NormalTok{, }\DataTypeTok{to=}\DecValTok{9}\NormalTok{, }\DataTypeTok{by=}\DecValTok{1}\NormalTok{)), }\DataTypeTok{Ancient=}\StringTok{'Parity_10'}\NormalTok{)) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{parity =} \KeywordTok{fct_drop}\NormalTok{(parity), }\DataTypeTok{parity_group =} \KeywordTok{fct_drop}\NormalTok{(parity_group))}
\end{Highlighting}
\end{Shaded}

The age\_days, weight\_kg and crl\_cm varibles can be left as numeric,
but we might want to create some new variables based on these\ldots{}

Create an age group variable as a factor and crl\_mm as a number:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{age_group =} \KeywordTok{cut}\NormalTok{(age_days, }\DataTypeTok{breaks=}\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{200}\NormalTok{, }\DecValTok{300}\NormalTok{), }
        \DataTypeTok{labels=}\KeywordTok{c}\NormalTok{(}\StringTok{'Early'}\NormalTok{, }\StringTok{'Middle'}\NormalTok{, }\StringTok{'Late'}\NormalTok{))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{crl_mm =}\NormalTok{ crl_cm}\OperatorTok{*}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The head\_width\_mm and head\_length\_mm variables are OK as numeric.

Convert all of the hair variables into factors one at a time:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_coronary_band =} \KeywordTok{parse_factor}\NormalTok{(hair_coronary_band, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{,}\StringTok{'Y'}\NormalTok{))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_coronary_band =} \KeywordTok{fct_collapse}\NormalTok{(hair_coronary_band, }\DataTypeTok{No =} \StringTok{'N'}\NormalTok{, }\DataTypeTok{Yes=}\StringTok{'Y'}\NormalTok{)) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_ear =} \KeywordTok{parse_factor}\NormalTok{(hair_ear, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{,}\StringTok{'Y'}\NormalTok{))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_ear =} \KeywordTok{fct_collapse}\NormalTok{(hair_ear, }\DataTypeTok{No =} \StringTok{'N'}\NormalTok{, }\DataTypeTok{Yes=}\StringTok{'Y'}\NormalTok{)) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_eyelid =} \KeywordTok{parse_factor}\NormalTok{(hair_eyelid, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{,}\StringTok{'Y'}\NormalTok{))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_eyelid =} \KeywordTok{fct_collapse}\NormalTok{(hair_eyelid, }\DataTypeTok{No =} \StringTok{'N'}\NormalTok{, }\DataTypeTok{Yes=}\StringTok{'Y'}\NormalTok{)) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_tail =} \KeywordTok{parse_factor}\NormalTok{(hair_tail, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{,}\StringTok{'Y'}\NormalTok{))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_tail =} \KeywordTok{fct_collapse}\NormalTok{(hair_tail, }\DataTypeTok{No =} \StringTok{'N'}\NormalTok{, }\DataTypeTok{Yes=}\StringTok{'Y'}\NormalTok{)) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_hornbud =} \KeywordTok{parse_factor}\NormalTok{(hair_hornbud, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{,}\StringTok{'Y'}\NormalTok{))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{hair_hornbud =} \KeywordTok{fct_collapse}\NormalTok{(hair_hornbud, }\DataTypeTok{No =} \StringTok{'N'}\NormalTok{, }\DataTypeTok{Yes=}\StringTok{'Y'}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Convert the tactile hair variables into factors:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{tactile_muzzle =} \KeywordTok{parse_factor}\NormalTok{(tactile_muzzle, }
                         \DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'Visible'}\NormalTok{,}\StringTok{'Not visible'}\NormalTok{,}\StringTok{'Hairsack'}\NormalTok{))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{tactile_eyebrow =} \KeywordTok{parse_factor}\NormalTok{(tactile_eyebrow,}
                         \DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'Visible'}\NormalTok{,}\StringTok{'Not visible'}\NormalTok{,}\StringTok{'Hairsack'}\NormalTok{))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{tactile_eyelash =} \KeywordTok{parse_factor}\NormalTok{(tactile_eyelash, }
                         \DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'Visible'}\NormalTok{,}\StringTok{'Not visible'}\NormalTok{,}\StringTok{'Hairsack'}\NormalTok{)))}
\end{Highlighting}
\end{Shaded}

Convert the remaining 4 variables into factors:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{eye_op_close =} \KeywordTok{parse_factor}\NormalTok{(eye_op_close, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'Closed'}\NormalTok{,}\StringTok{'Open'}\NormalTok{))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{papillae_tongue =} \KeywordTok{parse_factor}\NormalTok{(papillae_tongue, }
        \DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'None'}\NormalTok{,}\StringTok{'Furthest back'}\NormalTok{,}\StringTok{'Large front'}\NormalTok{,}\StringTok{'Whole tongue'}\NormalTok{))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{sex =} \KeywordTok{parse_factor}\NormalTok{(sex, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'Female'}\NormalTok{,}\StringTok{'Male'}\NormalTok{,}\StringTok{'Non Diff'}\NormalTok{))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{eyelid =} \KeywordTok{parse_factor}\NormalTok{(eyelid, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{'N'}\NormalTok{,}\StringTok{'Y'}\NormalTok{))) }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{eyelid =} \KeywordTok{fct_collapse}\NormalTok{(eyelid, }\DataTypeTok{No =} \StringTok{'N'}\NormalTok{, }\DataTypeTok{Yes=}\StringTok{'Y'}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{step-6-re-examine-the-structure-of-the-data-frame}{%
\subparagraph{Step 6: Re-examine the structure of the data
frame:}\label{step-6-re-examine-the-structure-of-the-data-frame}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{str}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Classes 'tbl_df', 'tbl' and 'data.frame':    262 obs. of  22 variables:
##  $ parity            : Factor w/ 6 levels "Parity_1","Parity_2",..: 3 2 1 1 2 3 2 2 6 4 ...
##  $ age_days          : num  274 196 259 249 221 221 177 82 193 142 ...
##  $ weight_kg         : num  35.5 10.2 27.1 29.1 16.6 ...
##  $ crl_cm            : num  86.8 61.8 89.3 83 75.4 77.7 55.4 10.4 62.4 35.4 ...
##  $ head_width_mm     : num  128 83.8 121 118 100.6 ...
##  $ head_length_mm    : num  239 154 220 215 183 ...
##  $ hair_coronary_band: Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 2 1 2 1 ...
##  $ hair_ear          : Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 1 1 1 1 ...
##  $ hair_eyelid       : Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 2 1 2 1 ...
##  $ hair_tail         : Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 2 1 2 1 ...
##  $ hair_hornbud      : Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 2 1 2 1 ...
##  $ tactile_muzzle    : Factor w/ 3 levels "Visible","Not visible",..: 1 1 1 1 1 1 1 2 1 1 ...
##  $ tactile_eyebrow   : Factor w/ 3 levels "Visible","Not visible",..: 1 1 1 1 1 1 1 2 1 1 ...
##  $ tactile_eyelash   : Factor w/ 3 levels "Visible","Not visible",..: 1 1 1 1 1 1 1 2 1 2 ...
##  $ eye_op_close      : Factor w/ 2 levels "Closed","Open": 2 2 2 2 2 2 1 1 1 1 ...
##  $ papillae_tongue   : Factor w/ 4 levels "None","Furthest back",..: 4 4 4 4 4 4 4 1 4 4 ...
##  $ eyelid            : Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 2 2 2 2 ...
##  $ sex               : Factor w/ 3 levels "Female","Male",..: 1 1 2 2 1 1 2 2 2 1 ...
##  $ ID                : Factor w/ 262 levels "ID_001","ID_002",..: 1 2 3 4 5 6 7 8 9 10 ...
##  $ parity_group      : Factor w/ 3 levels "First","Second",..: 3 2 1 1 2 3 2 2 3 3 ...
##  $ age_group         : Factor w/ 3 levels "Early","Middle",..: 3 2 3 3 3 3 2 1 2 2 ...
##  $ crl_mm            : num  868 618 893 830 754 777 554 104 624 354 ...
\end{verbatim}

The formats are all now correct - we no longer have any character
variables, or numbers that should be factors.

We can also re-order the data frame to keep important variables first,
and related variables together:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses <-}\StringTok{ }\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{select}\NormalTok{(ID, sex, }\KeywordTok{starts_with}\NormalTok{(}\StringTok{'parity'}\NormalTok{), }\KeywordTok{starts_with}\NormalTok{(}\StringTok{'age'}\NormalTok{), }
\NormalTok{           weight_kg, crl_cm, crl_mm, }\KeywordTok{starts_with}\NormalTok{(}\StringTok{'head'}\NormalTok{), }\KeywordTok{everything}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

Check the new order:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{str}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Classes 'tbl_df', 'tbl' and 'data.frame':    262 obs. of  22 variables:
##  $ ID                : Factor w/ 262 levels "ID_001","ID_002",..: 1 2 3 4 5 6 7 8 9 10 ...
##  $ sex               : Factor w/ 3 levels "Female","Male",..: 1 1 2 2 1 1 2 2 2 1 ...
##  $ parity            : Factor w/ 6 levels "Parity_1","Parity_2",..: 3 2 1 1 2 3 2 2 6 4 ...
##  $ parity_group      : Factor w/ 3 levels "First","Second",..: 3 2 1 1 2 3 2 2 3 3 ...
##  $ age_days          : num  274 196 259 249 221 221 177 82 193 142 ...
##  $ age_group         : Factor w/ 3 levels "Early","Middle",..: 3 2 3 3 3 3 2 1 2 2 ...
##  $ weight_kg         : num  35.5 10.2 27.1 29.1 16.6 ...
##  $ crl_cm            : num  86.8 61.8 89.3 83 75.4 77.7 55.4 10.4 62.4 35.4 ...
##  $ crl_mm            : num  868 618 893 830 754 777 554 104 624 354 ...
##  $ head_width_mm     : num  128 83.8 121 118 100.6 ...
##  $ head_length_mm    : num  239 154 220 215 183 ...
##  $ hair_coronary_band: Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 2 1 2 1 ...
##  $ hair_ear          : Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 1 1 1 1 ...
##  $ hair_eyelid       : Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 2 1 2 1 ...
##  $ hair_tail         : Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 2 1 2 1 ...
##  $ hair_hornbud      : Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 2 1 2 1 ...
##  $ tactile_muzzle    : Factor w/ 3 levels "Visible","Not visible",..: 1 1 1 1 1 1 1 2 1 1 ...
##  $ tactile_eyebrow   : Factor w/ 3 levels "Visible","Not visible",..: 1 1 1 1 1 1 1 2 1 1 ...
##  $ tactile_eyelash   : Factor w/ 3 levels "Visible","Not visible",..: 1 1 1 1 1 1 1 2 1 2 ...
##  $ eye_op_close      : Factor w/ 2 levels "Closed","Open": 2 2 2 2 2 2 1 1 1 1 ...
##  $ papillae_tongue   : Factor w/ 4 levels "None","Furthest back",..: 4 4 4 4 4 4 4 1 4 4 ...
##  $ eyelid            : Factor w/ 2 levels "No","Yes": 2 2 2 2 2 2 2 2 2 2 ...
\end{verbatim}

\hypertarget{step-7-examine-the-data}{%
\subparagraph{Step 7: examine the data}\label{step-7-examine-the-data}}

A basic examination is done using summary:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fetuses }\OperatorTok{%>%}
\StringTok{    }\KeywordTok{summary}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##        ID            sex           parity   parity_group    age_days     
##  ID_001 :  1   Female  :110   Parity_1:47   First : 47   Min.   : 25.00  
##  ID_002 :  1   Male    :128   Parity_2:83   Second: 83   1st Qu.: 95.25  
##  ID_003 :  1   Non Diff: 24   Parity_3:60   Older :132   Median :136.00  
##  ID_004 :  1                  Parity_4:47                Mean   :136.06  
##  ID_005 :  1                  Parity_5:10                3rd Qu.:175.00  
##  ID_006 :  1                  Parity_6:15                Max.   :274.00  
##  (Other):256                                                             
##   age_group     weight_kg           crl_cm           crl_mm      
##  Early : 73   Min.   : 0.0010   Min.   :  2.00   Min.   :  20.0  
##  Middle:159   1st Qu.: 0.2537   1st Qu.: 18.30   1st Qu.: 183.0  
##  Late  : 30   Median : 1.7805   Median : 35.65   Median : 356.5  
##               Mean   : 5.0029   Mean   : 37.90   Mean   : 379.0  
##               3rd Qu.: 6.9250   3rd Qu.: 54.60   3rd Qu.: 546.0  
##               Max.   :41.6000   Max.   :101.30   Max.   :1013.0  
##                                                                  
##  head_width_mm    head_length_mm   hair_coronary_band hair_ear  hair_eyelid
##  Min.   :  3.00   Min.   :  5.00   No :202            No :221   No :197    
##  1st Qu.: 39.24   1st Qu.: 55.52   Yes: 60            Yes: 41   Yes: 65    
##  Median : 63.33   Median :101.28                                           
##  Mean   : 62.34   Mean   :103.29                                           
##  3rd Qu.: 84.02   3rd Qu.:145.54                                           
##  Max.   :152.00   Max.   :239.00                                           
##                                                                            
##  hair_tail hair_hornbud     tactile_muzzle    tactile_eyebrow
##  No :179   No :175      Visible    :169    Visible    :169   
##  Yes: 83   Yes: 87      Not visible: 34    Not visible: 43   
##                         Hairsack   : 59    Hairsack   : 50   
##                                                              
##                                                              
##                                                              
##                                                              
##     tactile_eyelash eye_op_close      papillae_tongue eyelid   
##  Visible    :109    Closed:225   None         : 35    No : 21  
##  Not visible:130    Open  : 37   Furthest back: 28    Yes:241  
##  Hairsack   : 23                 Large front  : 35             
##                                  Whole tongue :164             
##                                                                
##                                                                
## 
\end{verbatim}

We specifically need to check for:

\begin{itemize}
\item
  Are there any unexpected missing values in any of the variables?
\item
  Are there extreme observations in the numeric variables (indicated by
  a very low min and/or very high max?)
\item
  Do the mean and median of numeric variables look plausible?
\item
  Do the total number of observations within factor variables look
  plausible?
\end{itemize}

A more detailed examination may require graphs!

\hypertarget{step-8-carry-on-with-your-data-analysis}{%
\subparagraph{Step 8: carry on with your data
analysis}\label{step-8-carry-on-with-your-data-analysis}}

It is a good idea to get into the habit of having separate R script
files for data reading/formatting (i.e.~steps 1-7) and data analysis.
This helps to keep your R script files shorter and therefore more
manageable, and also means that several different data analyses can use
the same data reading/formatting R script. For example, you could create
a new R script file and save it with the name `analysis\_fetuses.R'.
Then at the top of your new R script file put the following command:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{source}\NormalTok{(}\StringTok{"tidy_fetuses.R"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Now if you want to re-load and re-format the data, all you have to do is
make sure that your working directory is correct then run this single
line in your analysis script. That means that you can get straight into
the analysis without having to scroll through all of the code needed to
read and format the data. If you get an error saying ``cannot open file
`tidy\_fetuses.R': No such file or directory'' when running this
command, then check that you saved your `tidy\_fetuses.R' file in the
same folder as the `calf\_fetuses.xlsx' data file as instructed at the
start of the tutorial.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\end{document}
