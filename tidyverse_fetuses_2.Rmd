---
title: "Importing and Cleaning Data in the R tidyverse 2"
output:
 html_document:
  keep_md: yes
 pdf_document: default
 word_document: default
---

```{r setup, include=FALSE}
# Seems to break purl for some reason:
# knitr::opts_chunk$set(echo = TRUE)
options(width = 80)
# To create .R file:
# knitr::purl('tidyverse_fetuses.Rmd', documentation=2)
knitr::opts_knit$set(root.dir = "P:/Undervisning/Differentiering 2019/Revision_diff_undervisning/fetuses_spiral")

```

---

##### Matt Denwood, University of Copenhagen

--- 

# File 2

## Section 2: working with different variable types

---

### As we have seen in the previous file, we need to prepare the data for analysis. We first load the relevant libraries and the data:

```{r, warning=FALSE}
library('tidyverse')
library('readxl')
fetuses <- read_excel('calf_fetuses.xlsx', sheet='calf_fetuses')

```

### And again we make a "backup" of the full dataset:

```{r}
fetuses_full <- fetuses %>%
	mutate(crl_mm = crl_cm*10)
```

### And we assign ID to the animals from the backup data:

```{r}
fetuses <- fetuses_full %>%
	mutate(ID = row_number()) %>%
	select(ID, parity, age_days, hair_coronary_band) %>%
	filter(age_days >= 50)
```

###Then we´re good to go.


### Converting numbers into factors

Most of the time we will be creating factors from text entries, but occasionally we will want to create factors from numbers.  The best approach to use depends on whether the number is a discrete number (i.e. whole numbers only), or a continuous number.  Let us take them one at a time.

For **discrete numbers**, we can use the parse_factor() function like before - but we first need to turn the integer into a character (text) variable.  It is also a good idea to add some text to the number so that the resulting factor is more easily distinguishable from a 'true number'. We can accomplish both tasks simultaneously using the str_c() function, for example:

```{r}
fetuses %>%
	mutate(parity_text = str_c('Parity_', parity)) %>%
	mutate(parity_fct = parse_factor(parity_text)) %>%
	str()
```

This has been broken down into stages so that you can see what is going on.  The first step uses str_c() to create a new character variable by sticking the text 'Parity_' before the parity number, and the second step creates a factor from the character variable as we did before.  The only problem with this is that we haven't specified levels to parse_factor(), so if we have any errors in the data (e.g. a negative number for parity) then we will not detect these.  A good trick is to automatically create a wide range of possible parity levels without having to type them all out:

```{r}
str_c('Parity_', seq(from=1, to=10, by=1))
```

The seq() function creates all possible numbers between from (1) and to (10), with increments of by (1). If you already knew that the range was narrower (for example only parities 1 to 6 were observed) then you could adjust the code accordingly - we will discuss a way to check this later on.

We can then use our generated parity levels in the parse_factor function, and combine all steps of the code together:

```{r}
fetuses <- fetuses %>%
	mutate(parity_fct = parse_factor(str_c('Parity_', parity), 
		levels=str_c('Parity_', seq(from=1, to=10, by=1)))) %>%
	mutate(parity_group = fct_collapse(parity_fct, First='Parity_1', Second='Parity_2', 
		Older=str_c('Parity_', seq(from=3, to=9, by=1)), Ancient='Parity_10'))

fetuses %>%
	summary()
```

This code looks quite complicated, but if you break it down into steps you should be able to see what is going on.  The first mutate function just combines the separate steps we had before - first using str_c() to add the text 'Parity_' to the parity number, then parsing this into a factor using specified levels.  The second mutate function uses fct_collapse to create a second factor of parity_group, where we combine parities 3-9 into a single group.

Notice here that we specified a factor level that doesn't exist in the data - there are no Parity_10 cows (and therefore no Ancient cows).  In some situations this is helpful: we can include a possible factor level and R will explictly tell us that there are no observations within that category.  But if we want to remove the unused factor levels, we can do this using the fct_drop function:

```{r}
fetuses <- fetuses %>%
	mutate(parity_fct = fct_drop(parity_fct), parity_group = fct_drop(parity_group))

fetuses %>%
	summary()
```

There is now no more mention of 'Ancient' cows in parity_group.  Notice here that rather than using two separate mutate() functions, I mutated two variables within the same function separated by a comma.  The two approaches are the same.

There is a second discrete number that makes sense to convert into a factor:  our ID variable is currently stored as a number, but it makes more sense to think of it as a grouping variable i.e. a factor.  Sometimes this doesn't make any difference, but if we want to use ID either to merge datasets, or as a stratifying variable in a plot or in a model, then we might get the wrong result if ID is a number.  So we had better turn it into a factor:

```{r}
fetuses <- fetuses %>%
	mutate(ID_simple = parse_factor(str_c('ID_', ID)))  %>%
	mutate(ID = parse_factor(str_c('ID_', str_replace_all(format(ID),' ','0'))))

fetuses
```

Two different methods are used here - the first simple method works fine, but the resulting IDs are ID_1, ID_2, ... ID_10, ID_11, ... ID_99, ID_100 etc.  So when these are sorted alphabetically, they end up in a different order to the numbers themselves.  The second method is slightly more complex but gives us ID numbers ID_001, ID_002, ... ID_010, ID_011, ... ID_099, ID_100 etc so that the order is preserved.  If you are interested in how the format() and str_replace_all() functions work, look at their help files by typing ?format and ?str_replace_all in R.

--- 

```{r echo=FALSE}
# Another way to do it for our reference - but less obvious I think
temp <- fetuses %>%
	mutate(parity_fct = parse_factor(str_c(parity))) %>%
	mutate(parity_fct = fct_relabel(parity_fct, ~ str_c('Parity_', .)))
# This chunk is NOT included!
```


Turning **continous numbers into factors** uses a slightly different method with the cut() function rather than parse_string.  The cut function allows you to break a continuous variable into segments using specified breakpoints and corresponding labels for the factor levels.  For example we can turn the age into a factor to reflect an early, mid or late stage foetus:

```{r}
fetuses <- fetuses %>%
	mutate(age_group = cut(age_days, breaks=c(0, 100, 200, 300), labels=c('Early', 'Middle', 'Late')))

fetuses %>%
	summary()
```

The breaks argument must always specify the lowest and highest possible values as the first and last numbers, so there is always one more group label than there are breaks.  By default the breaks define intervals that are open on the left and closed on the right, so a number exactly equal to a break goes into the category below this break.  For example, here we have categories defined as:

- **Early**:  0 < age <= 100  (including age = 100)

- **Middle**:  100 < age <= 200   (including age = 200)

- **Late**:  200 < age <= 300  (including age = 300)

Notice that an age of 0 is NOT included in the Early category: this would be converted to a missing value in the factor along with any values below 0 or above 300.  If you want to include all possible values, then you can specify the first and last breaks as -Inf and Inf - meaning negative infinity and infinity.

We can also use the cut function with discrete numbers, although we have to be even more careful about the rules for closed vs open intervals because it will happen more often (for example, an age of exactly 100 days is far less likely than a parity of exactly 3).  Alternatively, you can specify the breaks as being mid-way between the discrete values to make the code more obvious, for example:

```{r}
fetuses <- fetuses %>%
	mutate(parity_fct_cut = cut(parity, breaks=c(0.5, 1.5, 2.5, 10.5), labels=c('First','Second','Older')))

fetuses %>%
	summary()
```

This parity_fct_cut variable is identical to the parity_fct variable that we created above.

--- 

### More variable types

Although our fetuses data only has numeric and factor variable types, we will sometimes encounter other types of data.  The most common of these are dates, date/times, ordinal, logical, and numbers with specialised formats (e.g. currency symbols).

#### Dates

Dates are a very specific type of variable that we can do special things with, such as calculating the number of days between two dates, and extracting parts of the date e.g. the year, day of the week, month name etc.  But in order to be able to do this, R must first store the variable as a date.  When reading an Excel file using read_excel this is usually done automatically, but sometimes we can end up with a text variable that contains text representing the date.  In this case, we can use the parse_date function if the date is written in the ISO standard format of YYYY-MM-DD:

```{r}
parse_date('2010-10-21')
```

If the date is written in a non-standard format (which is unfortunately more common than the standard format!), then you will need to tell R what format it is in.  The lubridate package has some helpful functions to do this, for example:

```{r}
library('lubridate')
ymd('2010/10/21')
make_date(year=2010, month=10, day=21)
dmy('21-10-2010')
mdy('10-21-2010')
```

A very common application of dates is to calculate a difference between two dates.  The best way to do this is to subtract one date from another, and then use the as.numeric function to convert the time difference into a simple number using the appropriate units.  For example:

```{r}
dt1 <- parse_date('2018-01-01')
dt1
dt2 <- parse_date('2018-02-03')
dt2
as.numeric(dt2 - dt1, units='days')
as.numeric(dt2 - dt1, units='weeks')
```

It is also possible to add or subtract a given number of days to a date in a similar way:

```{r}
dt1 + 33
dt1 - 1
```

#### Date/times

Dates are relatively simple to work with, but date/times have the additional complexity of time zones.  Unless you specifically need the time to be represented, you are much better off with simple dates.  Unfortunately, Excel will save dates as date/time objects so we end up with these when we import them to R.  For this reason, it is often a good idea to convert these to a simple date using the as.Date function, for example:

```{r}
dt <- as.POSIXct('2010-02-15 05:00')
dt
as.Date(dt)
```

---

#### Ordinal

There is an important theoretical difference between ordinal data (where there is an order to the categories observed, e.g. body condition score) and categorical data (where there is no logical order, e.g. breed).  This distinction is less important in R, so we tend to use factors to represent both.  However, there is a specific type of factor that it is occasionally useful to use, called an ordered factor.  These are created using the same parse_factor and cut functions that we explored earlier, but with the additional argument: ordered=TRUE.  For example:

```{r}
fetuses <- fetuses %>%
	mutate(parity_fct = parse_factor(str_c('Parity_', parity), 
		levels=str_c('Parity_', seq(from=1, to=10, by=1)))) %>%
	mutate(parity_ord = parse_factor(str_c('Parity_', parity), 
		levels=str_c('Parity_', seq(from=1, to=10, by=1)), ordered=TRUE))

fetuses %>%
	str()
```

Using parity_ord rather than parity_fct will make a subtle difference to the modelling functions, but will make no difference to plotting or stratifying by the variable.  Just temember that the order of the factor levels is more important for ordered factors than it is for standard (non-ordered) factors: this is why the levels are shown as "Parity_1"<"Parity_2"<.. rather than "Parity_1","Parity_2",.. in the output of str().

---

#### Logical

We can represent binary data as logical (FALSE/TRUE), and R has a special type called logical that can be used for this.  It is possible to use this type for e.g. results of diagnostic tests, where there is a logical FALSE/TRUE outcome.  However, the same thing can also be represented using a factor with two levels Negative/Positive, so for the sake of consistency it is generally a good idea to just stick to using factors.  To convert a logical variable into a factor variable, you can use the str_c function as we did for integer numbers:

```{r}
testresult <- c(FALSE, TRUE, NA)
testresult
str_c(testresult)
parse_factor(str_c(testresult), levels=c('FALSE','TRUE'))
```

To re-label FALSE and TRUE to Negative and Positive (or similar) and/or remove the NA (missing) factor level, use the fct_collapse (or similar fct_relabel) function as we did before.

---

#### Numbers with special formats

Sometimes we will want to read numbers from text, if for example there are non-numeric characters such as Â£ or â¬ in the text.  We can use the parse_number function to do this:


```{r}
price <- "â¬103,401"
parse_number(price)
```

Notice that R is english-centric by default, so a danish-formatted number will be parsed incorrectly:


```{r}
danish_price <- "DKK 103.401,00"
parse_number(danish_price)
```

We get DKK 103,40 rather than DKK 103.401 - but this can be overcome by setting the locale:


```{r}
danish_price <- "DKK 103.401,00"
parse_number(danish_price, locale=locale(decimal_mark = ",", grouping_mark = "."))
```

---

### Converting multiple columns

Let's go back to the original dataset fetuses_full:

```{r}
fetuses_full %>%
	summary()
```

We now know how to format each of these variables as either a factor or number one by one - for example:

```{r}
fetuses <- fetuses_full %>% 
	mutate(hair_coronary_band = parse_factor(hair_coronary_band, levels=c('N','Y'))) %>%
	mutate(hair_ear = parse_factor(hair_ear, levels=c('N','Y'))) %>% 
	mutate(hair_eyelid = parse_factor(hair_eyelid, levels=c('N','Y'))) %>% 
	mutate(hair_tail = parse_factor(hair_tail, levels=c('N','Y'))) %>% 
	mutate(hair_hornbud = parse_factor(hair_hornbud, levels=c('N','Y')))
```

And so on.  The best approach is to copy and paste the code and just change the name of the variable each time - it is a bit tedious but not difficult.  With a bit of practice, you will be surprised how quickly you can get this done.

A good tip is to quickly change all character (text) variables into factors and then immediately use summary on the result: this allows us to see what different values the data contains for each of the text variables.  We can do this using mutate_if and the condition is_character:

```{r}
fetuses %>% 
	mutate_if(is_character, parse_factor) %>%
	summary()
```

We don't specify the levels manually, but that's OK because all we wanted to do is quickly see what is in there - we are not saving the result (or any potential issues generated by data entry mistakes).

--- 

